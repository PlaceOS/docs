/*! @algolia/autocomplete-js 1.0.1 | MIT License | © Algolia, Inc. and contributors | https://github.com/algolia/autocomplete */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@algolia/autocomplete-js'] = {}));
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function createRef(initialValue) {
    return {
      current: initialValue
    };
  }

  function debounce(fn, time) {
    var timerId = undefined;
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (timerId) {
        clearTimeout(timerId);
      }

      timerId = setTimeout(function () {
        return fn.apply(void 0, args);
      }, time);
    };
  }

  var autocompleteId = 0;
  function generateAutocompleteId() {
    return "autocomplete-".concat(autocompleteId++);
  }

  function getAttributeValueByPath(record, path) {
    return path.reduce(function (current, key) {
      return current && current[key];
    }, record);
  }

  function getItemsCount(state) {
    if (state.collections.length === 0) {
      return 0;
    }

    return state.collections.reduce(function (sum, collection) {
      return sum + collection.items.length;
    }, 0);
  }

  /**
   * Throws an error if the condition is not met in development mode.
   * This is used to make development a better experience to provide guidance as
   * to where the error comes from.
   */
  function invariant(condition, message) {

    if (!condition) {
      throw new Error("[Autocomplete] ".concat(message));
    }
  }

  var warnCache = {
    current: {}
  };
  /**
   * Logs a warning if the condition is not met.
   * This is used to log issues in development environment only.
   */

  function warn(condition, message) {

    if (condition) {
      return;
    }

    var sanitizedMessage = message.trim();
    var hasAlreadyPrinted = warnCache.current[sanitizedMessage];

    if (!hasAlreadyPrinted) {
      warnCache.current[sanitizedMessage] = true; // eslint-disable-next-line no-console

      console.warn("[Autocomplete] ".concat(sanitizedMessage));
    }
  }

  function checkOptions(options) {
     "development" !== 'production' ? warn(!options.debug, 'The `debug` option is meant for development debugging and should not be used in production.') : void 0 ;
  }

  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$1(Object(source), true).forEach(function (key) {
          _defineProperty$1(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$1(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function createStore(reducer, props, onStoreStateChange) {
    var state = props.initialState;
    return {
      getState: function getState() {
        return state;
      },
      dispatch: function dispatch(action, payload) {
        var prevState = _objectSpread({}, state);

        state = reducer(state, {
          type: action,
          props: props,
          payload: payload
        });
        onStoreStateChange({
          state: state,
          prevState: prevState
        });
      }
    };
  }

  function flatten(values) {
    return values.reduce(function (a, b) {
      return a.concat(b);
    }, []);
  }

  /**
   * Returns the next active item ID from the current state.
   *
   * We allow circular keyboard navigation from the base index.
   * The base index can either be `null` (nothing is highlighted) or `0`
   * (the first item is highlighted).
   * The base index is allowed to get assigned `null` only if
   * `props.defaultActiveItemId` is `null`. This pattern allows to "stop"
   * by the actual query before navigating to other suggestions as seen on
   * Google or Amazon.
   *
   * @param moveAmount The offset to increment (or decrement) the last index
   * @param baseIndex The current index to compute the next index from
   * @param itemCount The number of items
   * @param defaultActiveItemId The default active index to fallback to
   */
  function getNextActiveItemId(moveAmount, baseIndex, itemCount, defaultActiveItemId) {
    if (moveAmount < 0 && (baseIndex === null || defaultActiveItemId !== null && baseIndex === 0)) {
      return itemCount + moveAmount;
    }

    var numericIndex = (baseIndex === null ? -1 : baseIndex) + moveAmount;

    if (numericIndex <= -1 || numericIndex >= itemCount) {
      return defaultActiveItemId === null ? null : 0;
    }

    return numericIndex;
  }

  var noop = function noop() {};

  function ownKeys$2(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$2(Object(source), true).forEach(function (key) {
          _defineProperty$2(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$2(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$1 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$1 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$1(obj);
  }
  function getNormalizedSources(getSources, params) {
    var seenSourceIds = [];
    return Promise.resolve(getSources(params)).then(function (sources) {
      invariant(Array.isArray(sources), "The `getSources` function must return an array of sources but returned type ".concat(JSON.stringify(_typeof$1(sources)), ":\n\n").concat(JSON.stringify(sources, null, 2)));
      return Promise.all(sources // We allow `undefined` and `false` sources to allow users to use
      // `Boolean(query) && source` (=> `false`).
      // We need to remove these values at this point.
      .filter(function (maybeSource) {
        return Boolean(maybeSource);
      }).map(function (source) {
        invariant(typeof source.sourceId === 'string', 'A source must provide a `sourceId` string.');

        if (seenSourceIds.includes(source.sourceId)) {
          throw new Error("[Autocomplete] The `sourceId` ".concat(JSON.stringify(source.sourceId), " is not unique."));
        }

        seenSourceIds.push(source.sourceId);

        var normalizedSource = _objectSpread$1({
          getItemInputValue: function getItemInputValue(_ref) {
            var state = _ref.state;
            return state.query;
          },
          getItemUrl: function getItemUrl() {
            return undefined;
          },
          onSelect: function onSelect(_ref2) {
            var setIsOpen = _ref2.setIsOpen;
            setIsOpen(false);
          },
          onActive: noop
        }, source);

        return Promise.resolve(normalizedSource);
      }));
    });
  }

  // We don't have access to the autocomplete source when we call `onKeyDown`
  // or `onClick` because those are native browser events.
  // However, we can get the source from the suggestion index.
  function getCollectionFromActiveItemId(state) {
    // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]
    // We want to get the accumulated counts:
    // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]
    var accumulatedCollectionsCount = state.collections.map(function (collections) {
      return collections.items.length;
    }).reduce(function (acc, collectionsCount, index) {
      var previousValue = acc[index - 1] || 0;
      var nextValue = previousValue + collectionsCount;
      acc.push(nextValue);
      return acc;
    }, []); // Based on the accumulated counts, we can infer the index of the suggestion.

    var collectionIndex = accumulatedCollectionsCount.reduce(function (acc, current) {
      if (current <= state.activeItemId) {
        return acc + 1;
      }

      return acc;
    }, 0);
    return state.collections[collectionIndex];
  }
  /**
   * Gets the highlighted index relative to a suggestion object (not the absolute
   * highlighted index).
   *
   * Example:
   *  [['a', 'b'], ['c', 'd', 'e'], ['f']]
   *                      ↑
   *         (absolute: 3, relative: 1)
   */


  function getRelativeActiveItemId(_ref) {
    var state = _ref.state,
        collection = _ref.collection;
    var isOffsetFound = false;
    var counter = 0;
    var previousItemsOffset = 0;

    while (isOffsetFound === false) {
      var currentCollection = state.collections[counter];

      if (currentCollection === collection) {
        isOffsetFound = true;
        break;
      }

      previousItemsOffset += currentCollection.items.length;
      counter++;
    }

    return state.activeItemId - previousItemsOffset;
  }

  function getActiveItem(state) {
    var collection = getCollectionFromActiveItemId(state);

    if (!collection) {
      return null;
    }

    var item = collection.items[getRelativeActiveItemId({
      state: state,
      collection: collection
    })];
    var source = collection.source;
    var itemInputValue = source.getItemInputValue({
      item: item,
      state: state
    });
    var itemUrl = source.getItemUrl({
      item: item,
      state: state
    });
    return {
      item: item,
      itemInputValue: itemInputValue,
      itemUrl: itemUrl,
      source: source
    };
  }

  function isOrContainsNode(parent, child) {
    return parent === child || parent.contains(child);
  }

  function ownKeys$3(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$3(Object(source), true).forEach(function (key) {
          _defineProperty$3(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$3(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function mapToAlgoliaResponse(rawResults) {
    var results = rawResults.map(function (result) {
      var _hits;

      return _objectSpread$2(_objectSpread$2({}, result), {}, {
        hits: (_hits = result.hits) === null || _hits === void 0 ? void 0 : _hits.map(function (hit) {
          // Bring support for the Insights plugin.
          return _objectSpread$2(_objectSpread$2({}, hit), {}, {
            __autocomplete_indexName: result.index,
            __autocomplete_queryID: result.queryID
          });
        })
      });
    });
    return {
      results: results,
      hits: results.map(function (result) {
        return result.hits;
      }).filter(Boolean),
      facetHits: results.map(function (result) {
        var _facetHits;

        return (_facetHits = result.facetHits) === null || _facetHits === void 0 ? void 0 : _facetHits.map(function (facetHit) {
          // Bring support for the highlighting components.
          return {
            label: facetHit.value,
            count: facetHit.count,
            _highlightResult: {
              label: {
                value: facetHit.highlighted
              }
            }
          };
        });
      }).filter(Boolean)
    };
  }

  function ownKeys$4(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$3(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$4(Object(source), true).forEach(function (key) {
          _defineProperty$4(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$4(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  function getAutocompleteSetters(_ref) {
    var store = _ref.store;

    var setActiveItemId = function setActiveItemId(value) {
      store.dispatch('setActiveItemId', value);
    };

    var setQuery = function setQuery(value) {
      store.dispatch('setQuery', value);
    };

    var setCollections = function setCollections(rawValue) {
      var baseItemId = 0;
      var value = rawValue.map(function (collection) {
        return _objectSpread$3(_objectSpread$3({}, collection), {}, {
          // We flatten the stored items to support calling `getAlgoliaResults`
          // from the source itself.
          items: flatten(collection.items).map(function (item) {
            return _objectSpread$3(_objectSpread$3({}, item), {}, {
              __autocomplete_id: baseItemId++
            });
          })
        });
      });
      store.dispatch('setCollections', value);
    };

    var setIsOpen = function setIsOpen(value) {
      store.dispatch('setIsOpen', value);
    };

    var setStatus = function setStatus(value) {
      store.dispatch('setStatus', value);
    };

    var setContext = function setContext(value) {
      store.dispatch('setContext', value);
    };

    return {
      setActiveItemId: setActiveItemId,
      setQuery: setQuery,
      setCollections: setCollections,
      setIsOpen: setIsOpen,
      setStatus: setStatus,
      setContext: setContext
    };
  }

  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
  }

  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _iterableToArray$1(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function ownKeys$5(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$4(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$5(Object(source), true).forEach(function (key) {
          _defineProperty$5(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$5(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$5(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  function getDefaultProps(props, pluginSubscribers) {
    var _props$id;
    /* eslint-disable no-restricted-globals */


    var environment = typeof window !== 'undefined' ? window : {};
    /* eslint-enable no-restricted-globals */

    var plugins = props.plugins || [];
    return _objectSpread$4(_objectSpread$4({
      debug: false,
      openOnFocus: false,
      placeholder: '',
      autoFocus: false,
      defaultActiveItemId: null,
      stallThreshold: 300,
      environment: environment,
      shouldPanelOpen: function shouldPanelOpen(_ref) {
        var state = _ref.state;
        return getItemsCount(state) > 0;
      }
    }, props), {}, {
      // Since `generateAutocompleteId` triggers a side effect (it increments
      // an internal counter), we don't want to execute it if unnecessary.
      id: (_props$id = props.id) !== null && _props$id !== void 0 ? _props$id : generateAutocompleteId(),
      plugins: plugins,
      // The following props need to be deeply defaulted.
      initialState: _objectSpread$4({
        activeItemId: null,
        query: '',
        completion: null,
        collections: [],
        isOpen: false,
        status: 'idle',
        context: {}
      }, props.initialState),
      onStateChange: function onStateChange(params) {
        var _props$onStateChange;

        (_props$onStateChange = props.onStateChange) === null || _props$onStateChange === void 0 ? void 0 : _props$onStateChange.call(props, params);
        plugins.forEach(function (x) {
          var _x$onStateChange;

          return (_x$onStateChange = x.onStateChange) === null || _x$onStateChange === void 0 ? void 0 : _x$onStateChange.call(x, params);
        });
      },
      onSubmit: function onSubmit(params) {
        var _props$onSubmit;

        (_props$onSubmit = props.onSubmit) === null || _props$onSubmit === void 0 ? void 0 : _props$onSubmit.call(props, params);
        plugins.forEach(function (x) {
          var _x$onSubmit;

          return (_x$onSubmit = x.onSubmit) === null || _x$onSubmit === void 0 ? void 0 : _x$onSubmit.call(x, params);
        });
      },
      onReset: function onReset(params) {
        var _props$onReset;

        (_props$onReset = props.onReset) === null || _props$onReset === void 0 ? void 0 : _props$onReset.call(props, params);
        plugins.forEach(function (x) {
          var _x$onReset;

          return (_x$onReset = x.onReset) === null || _x$onReset === void 0 ? void 0 : _x$onReset.call(x, params);
        });
      },
      getSources: function getSources(params) {
        return Promise.all([].concat(_toConsumableArray$1(plugins.map(function (plugin) {
          return plugin.getSources;
        })), [props.getSources]).filter(Boolean).map(function (getSources) {
          return getNormalizedSources(getSources, params);
        })).then(function (nested) {
          return flatten(nested);
        }).then(function (sources) {
          return sources.map(function (source) {
            return _objectSpread$4(_objectSpread$4({}, source), {}, {
              onSelect: function onSelect(params) {
                source.onSelect(params);
                pluginSubscribers.forEach(function (x) {
                  var _x$onSelect;

                  return (_x$onSelect = x.onSelect) === null || _x$onSelect === void 0 ? void 0 : _x$onSelect.call(x, params);
                });
              },
              onActive: function onActive(params) {
                source.onActive(params);
                pluginSubscribers.forEach(function (x) {
                  var _x$onActive;

                  return (_x$onActive = x.onActive) === null || _x$onActive === void 0 ? void 0 : _x$onActive.call(x, params);
                });
              }
            });
          });
        });
      },
      navigator: _objectSpread$4({
        navigate: function navigate(_ref2) {
          var itemUrl = _ref2.itemUrl;
          environment.location.assign(itemUrl);
        },
        navigateNewTab: function navigateNewTab(_ref3) {
          var itemUrl = _ref3.itemUrl;
          var windowReference = environment.open(itemUrl, '_blank', 'noopener');
          windowReference === null || windowReference === void 0 ? void 0 : windowReference.focus();
        },
        navigateNewWindow: function navigateNewWindow(_ref4) {
          var itemUrl = _ref4.itemUrl;
          environment.open(itemUrl, '_blank', 'noopener');
        }
      }, props.navigator)
    });
  }

  function _typeof$2(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$2 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$2 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$2(obj);
  }

  function _toConsumableArray$2(arr) {
    return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$2();
  }

  function _nonIterableSpread$2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$2(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
  }

  function _iterableToArray$2(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$2(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$2(arr);
  }

  function _arrayLikeToArray$2(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function ownKeys$6(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$5(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$6(Object(source), true).forEach(function (key) {
          _defineProperty$6(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$6(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$6(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function isDescription(item) {
    return Boolean(item.execute);
  }

  function isRequesterDescription(description) {
    return Boolean(description.execute);
  }

  function preResolve(itemsOrDescription, sourceId) {
    if (isRequesterDescription(itemsOrDescription)) {
      return _objectSpread$5(_objectSpread$5({}, itemsOrDescription), {}, {
        requests: itemsOrDescription.queries.map(function (query) {
          return {
            query: query,
            sourceId: sourceId,
            transformResponse: itemsOrDescription.transformResponse
          };
        })
      });
    }

    return {
      items: itemsOrDescription,
      sourceId: sourceId
    };
  }
  function resolve(items) {
    var packed = items.reduce(function (acc, current) {
      if (!isDescription(current)) {
        acc.push(current);
        return acc;
      }

      var searchClient = current.searchClient,
          execute = current.execute,
          requests = current.requests;
      var container = acc.find(function (item) {
        return isDescription(current) && isDescription(item) && item.searchClient === searchClient && item.execute === execute;
      });

      if (container) {
        var _container$items;

        (_container$items = container.items).push.apply(_container$items, _toConsumableArray$2(requests));
      } else {
        var request = {
          execute: execute,
          items: requests,
          searchClient: searchClient
        };
        acc.push(request);
      }

      return acc;
    }, []);
    var values = packed.map(function (maybeDescription) {
      if (!isDescription(maybeDescription)) {
        return Promise.resolve(maybeDescription);
      }

      var _ref = maybeDescription,
          execute = _ref.execute,
          items = _ref.items,
          searchClient = _ref.searchClient;
      return execute({
        searchClient: searchClient,
        requests: items
      });
    });
    return Promise.all(values).then(function (responses) {
      return flatten(responses);
    });
  }
  function postResolve(responses, sources) {
    return sources.map(function (source) {
      var matches = responses.filter(function (response) {
        return response.sourceId === source.sourceId;
      });
      var results = matches.map(function (_ref2) {
        var items = _ref2.items;
        return items;
      });
      var transform = matches[0].transformResponse;
      var items = transform ? transform(mapToAlgoliaResponse(results)) : results;
      invariant(Array.isArray(items), "The `getItems` function must return an array of items but returned type ".concat(JSON.stringify(_typeof$2(items)), ":\n\n").concat(JSON.stringify(items, null, 2)));
      return {
        source: source,
        items: items
      };
    });
  }

  function ownKeys$7(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$6(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$7(Object(source), true).forEach(function (key) {
          _defineProperty$7(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$7(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$7(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectWithoutProperties$1(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$1(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
  var lastStalledId = null;
  function onInput(_ref) {
    var event = _ref.event,
        _ref$nextState = _ref.nextState,
        nextState = _ref$nextState === void 0 ? {} : _ref$nextState,
        props = _ref.props,
        query = _ref.query,
        refresh = _ref.refresh,
        store = _ref.store,
        setters = _objectWithoutProperties$1(_ref, ["event", "nextState", "props", "query", "refresh", "store"]);

    if (lastStalledId) {
      props.environment.clearTimeout(lastStalledId);
    }

    var setCollections = setters.setCollections,
        setIsOpen = setters.setIsOpen,
        setQuery = setters.setQuery,
        setActiveItemId = setters.setActiveItemId,
        setStatus = setters.setStatus;
    setQuery(query);
    setActiveItemId(props.defaultActiveItemId);

    if (!query && props.openOnFocus === false) {
      var _nextState$isOpen;

      setStatus('idle');
      setCollections(store.getState().collections.map(function (collection) {
        return _objectSpread$6(_objectSpread$6({}, collection), {}, {
          items: []
        });
      }));
      setIsOpen((_nextState$isOpen = nextState.isOpen) !== null && _nextState$isOpen !== void 0 ? _nextState$isOpen : props.shouldPanelOpen({
        state: store.getState()
      }));
      return Promise.resolve();
    }

    setStatus('loading');
    lastStalledId = props.environment.setTimeout(function () {
      setStatus('stalled');
    }, props.stallThreshold);
    return props.getSources(_objectSpread$6({
      query: query,
      refresh: refresh,
      state: store.getState()
    }, setters)).then(function (sources) {
      setStatus('loading');
      return Promise.all(sources.map(function (source) {
        return Promise.resolve(source.getItems(_objectSpread$6({
          query: query,
          refresh: refresh,
          state: store.getState()
        }, setters))).then(function (itemsOrDescription) {
          return preResolve(itemsOrDescription, source.sourceId);
        });
      })).then(resolve).then(function (responses) {
        return postResolve(responses, sources);
      }).then(function (collections) {
        var _nextState$isOpen2;

        setStatus('idle');
        setCollections(collections);
        var isPanelOpen = props.shouldPanelOpen({
          state: store.getState()
        });
        setIsOpen((_nextState$isOpen2 = nextState.isOpen) !== null && _nextState$isOpen2 !== void 0 ? _nextState$isOpen2 : props.openOnFocus && !query && isPanelOpen || isPanelOpen);
        var highlightedItem = getActiveItem(store.getState());

        if (store.getState().activeItemId !== null && highlightedItem) {
          var item = highlightedItem.item,
              itemInputValue = highlightedItem.itemInputValue,
              itemUrl = highlightedItem.itemUrl,
              source = highlightedItem.source;
          source.onActive(_objectSpread$6({
            event: event,
            item: item,
            itemInputValue: itemInputValue,
            itemUrl: itemUrl,
            refresh: refresh,
            source: source,
            state: store.getState()
          }, setters));
        }
      }).finally(function () {
        if (lastStalledId) {
          props.environment.clearTimeout(lastStalledId);
        }
      });
    });
  }

  function ownKeys$8(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$7(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$8(Object(source), true).forEach(function (key) {
          _defineProperty$8(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$8(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$8(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectWithoutProperties$2(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$2(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
  function onKeyDown(_ref) {
    var event = _ref.event,
        props = _ref.props,
        refresh = _ref.refresh,
        store = _ref.store,
        setters = _objectWithoutProperties$2(_ref, ["event", "props", "refresh", "store"]);

    if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
      // Default browser behavior changes the caret placement on ArrowUp and
      // Arrow down.
      event.preventDefault();
      store.dispatch(event.key, null);
      var nodeItem = props.environment.document.getElementById("".concat(props.id, "-item-").concat(store.getState().activeItemId));

      if (nodeItem) {
        if (nodeItem.scrollIntoViewIfNeeded) {
          nodeItem.scrollIntoViewIfNeeded(false);
        } else {
          nodeItem.scrollIntoView(false);
        }
      }

      var highlightedItem = getActiveItem(store.getState());

      if (store.getState().activeItemId !== null && highlightedItem) {
        var item = highlightedItem.item,
            itemInputValue = highlightedItem.itemInputValue,
            itemUrl = highlightedItem.itemUrl,
            source = highlightedItem.source;
        source.onActive(_objectSpread$7({
          event: event,
          item: item,
          itemInputValue: itemInputValue,
          itemUrl: itemUrl,
          refresh: refresh,
          source: source,
          state: store.getState()
        }, setters));
      }
    } else if (event.key === 'Escape') {
      // This prevents the default browser behavior on `input[type="search"]`
      // from removing the query right away because we first want to close the
      // panel.
      event.preventDefault();
      store.dispatch(event.key, null);
    } else if (event.key === 'Enter') {
      // No active item, so we let the browser handle the native `onSubmit` form
      // event.
      if (store.getState().activeItemId === null || store.getState().collections.every(function (collection) {
        return collection.items.length === 0;
      })) {
        return;
      } // This prevents the `onSubmit` event to be sent because an item is
      // highlighted.


      event.preventDefault();

      var _ref2 = getActiveItem(store.getState()),
          _item = _ref2.item,
          _itemInputValue = _ref2.itemInputValue,
          _itemUrl = _ref2.itemUrl,
          _source = _ref2.source;

      if (event.metaKey || event.ctrlKey) {
        if (_itemUrl !== undefined) {
          _source.onSelect(_objectSpread$7({
            event: event,
            item: _item,
            itemInputValue: _itemInputValue,
            itemUrl: _itemUrl,
            refresh: refresh,
            source: _source,
            state: store.getState()
          }, setters));

          props.navigator.navigateNewTab({
            itemUrl: _itemUrl,
            item: _item,
            state: store.getState()
          });
        }
      } else if (event.shiftKey) {
        if (_itemUrl !== undefined) {
          _source.onSelect(_objectSpread$7({
            event: event,
            item: _item,
            itemInputValue: _itemInputValue,
            itemUrl: _itemUrl,
            refresh: refresh,
            source: _source,
            state: store.getState()
          }, setters));

          props.navigator.navigateNewWindow({
            itemUrl: _itemUrl,
            item: _item,
            state: store.getState()
          });
        }
      } else if (event.altKey) ; else {
        if (_itemUrl !== undefined) {
          _source.onSelect(_objectSpread$7({
            event: event,
            item: _item,
            itemInputValue: _itemInputValue,
            itemUrl: _itemUrl,
            refresh: refresh,
            source: _source,
            state: store.getState()
          }, setters));

          props.navigator.navigate({
            itemUrl: _itemUrl,
            item: _item,
            state: store.getState()
          });
          return;
        }

        onInput(_objectSpread$7({
          event: event,
          nextState: {
            isOpen: false
          },
          props: props,
          query: _itemInputValue,
          refresh: refresh,
          store: store
        }, setters)).then(function () {
          _source.onSelect(_objectSpread$7({
            event: event,
            item: _item,
            itemInputValue: _itemInputValue,
            itemUrl: _itemUrl,
            refresh: refresh,
            source: _source,
            state: store.getState()
          }, setters));
        });
      }
    }
  }

  function ownKeys$9(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$8(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$9(Object(source), true).forEach(function (key) {
          _defineProperty$9(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$9(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$9(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectWithoutProperties$3(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$3(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose$3(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
  function getPropGetters(_ref) {
    var props = _ref.props,
        refresh = _ref.refresh,
        store = _ref.store,
        setters = _objectWithoutProperties$3(_ref, ["props", "refresh", "store"]);

    var getEnvironmentProps = function getEnvironmentProps(providedProps) {
      var inputElement = providedProps.inputElement,
          formElement = providedProps.formElement,
          panelElement = providedProps.panelElement,
          rest = _objectWithoutProperties$3(providedProps, ["inputElement", "formElement", "panelElement"]);

      return _objectSpread$8({
        // On touch devices, we do not rely on the native `blur` event of the
        // input to close the panel, but rather on a custom `touchstart` event
        // outside of the autocomplete elements.
        // This ensures a working experience on mobile because we blur the input
        // on touch devices when the user starts scrolling (`touchmove`).
        onTouchStart: function onTouchStart(event) {
          if (store.getState().isOpen === false || event.target === inputElement) {
            return;
          } // @TODO: support cases where there are multiple Autocomplete instances.
          // Right now, a second instance makes this computation return false.


          var isTargetWithinAutocomplete = [formElement, panelElement].some(function (contextNode) {
            return isOrContainsNode(contextNode, event.target) || isOrContainsNode(contextNode, props.environment.document.activeElement);
          });

          if (isTargetWithinAutocomplete === false) {
            store.dispatch('blur', null);
          }
        },
        // When scrolling on touch devices (mobiles, tablets, etc.), we want to
        // mimic the native platform behavior where the input is blurred to
        // hide the virtual keyboard. This gives more vertical space to
        // discover all the suggestions showing up in the panel.
        onTouchMove: function onTouchMove(event) {
          if (store.getState().isOpen === false || inputElement !== props.environment.document.activeElement || event.target === inputElement) {
            return;
          }

          inputElement.blur();
        }
      }, rest);
    };

    var getRootProps = function getRootProps(rest) {
      return _objectSpread$8({
        role: 'combobox',
        'aria-expanded': store.getState().isOpen,
        'aria-haspopup': 'listbox',
        'aria-owns': store.getState().isOpen ? "".concat(props.id, "-list") : undefined,
        'aria-labelledby': "".concat(props.id, "-label")
      }, rest);
    };

    var getFormProps = function getFormProps(providedProps) {
      var inputElement = providedProps.inputElement,
          rest = _objectWithoutProperties$3(providedProps, ["inputElement"]);

      return _objectSpread$8({
        action: '',
        noValidate: true,
        role: 'search',
        onSubmit: function onSubmit(event) {
          var _providedProps$inputE;

          event.preventDefault();
          props.onSubmit(_objectSpread$8({
            event: event,
            refresh: refresh,
            state: store.getState()
          }, setters));
          store.dispatch('submit', null);
          (_providedProps$inputE = providedProps.inputElement) === null || _providedProps$inputE === void 0 ? void 0 : _providedProps$inputE.blur();
        },
        onReset: function onReset(event) {
          var _providedProps$inputE2;

          event.preventDefault();
          props.onReset(_objectSpread$8({
            event: event,
            refresh: refresh,
            state: store.getState()
          }, setters));
          store.dispatch('reset', null);
          (_providedProps$inputE2 = providedProps.inputElement) === null || _providedProps$inputE2 === void 0 ? void 0 : _providedProps$inputE2.focus();
        }
      }, rest);
    };

    var getInputProps = function getInputProps(providedProps) {
      function onFocus(event) {
        // We want to trigger a query when `openOnFocus` is true
        // because the panel should open with the current query.
        if (props.openOnFocus || Boolean(store.getState().query)) {
          onInput(_objectSpread$8({
            event: event,
            props: props,
            query: store.getState().completion || store.getState().query,
            refresh: refresh,
            store: store
          }, setters));
        }

        store.dispatch('focus', null);
      }

      var isTouchDevice = ('ontouchstart' in props.environment);

      var _ref2 = providedProps || {},
          inputElement = _ref2.inputElement,
          _ref2$maxLength = _ref2.maxLength,
          maxLength = _ref2$maxLength === void 0 ? 512 : _ref2$maxLength,
          rest = _objectWithoutProperties$3(_ref2, ["inputElement", "maxLength"]);

      var activeItem = getActiveItem(store.getState());
      return _objectSpread$8({
        'aria-autocomplete': 'both',
        'aria-activedescendant': store.getState().isOpen && store.getState().activeItemId !== null ? "".concat(props.id, "-item-").concat(store.getState().activeItemId) : undefined,
        'aria-controls': store.getState().isOpen ? "".concat(props.id, "-list") : undefined,
        'aria-labelledby': "".concat(props.id, "-label"),
        value: store.getState().completion || store.getState().query,
        id: "".concat(props.id, "-input"),
        autoComplete: 'off',
        autoCorrect: 'off',
        autoCapitalize: 'off',
        enterKeyHint: activeItem !== null && activeItem !== void 0 && activeItem.itemUrl ? 'go' : 'search',
        spellCheck: 'false',
        autoFocus: props.autoFocus,
        placeholder: props.placeholder,
        maxLength: maxLength,
        type: 'search',
        onChange: function onChange(event) {
          onInput(_objectSpread$8({
            event: event,
            props: props,
            query: event.currentTarget.value.slice(0, maxLength),
            refresh: refresh,
            store: store
          }, setters));
        },
        onKeyDown: function onKeyDown$1(event) {
          onKeyDown(_objectSpread$8({
            event: event,
            props: props,
            refresh: refresh,
            store: store
          }, setters));
        },
        onFocus: onFocus,
        onBlur: function onBlur() {
          // We do rely on the `blur` event on touch devices.
          // See explanation in `onTouchStart`.
          if (!isTouchDevice) {
            store.dispatch('blur', null);
          }
        },
        onClick: function onClick(event) {
          // When the panel is closed and you click on the input while
          // the input is focused, the `onFocus` event is not triggered
          // (default browser behavior).
          // In an autocomplete context, it makes sense to open the panel in this
          // case.
          // We mimic this event by catching the `onClick` event which
          // triggers the `onFocus` for the panel to open.
          if (providedProps.inputElement === props.environment.document.activeElement && !store.getState().isOpen) {
            onFocus(event);
          }
        }
      }, rest);
    };

    var getLabelProps = function getLabelProps(rest) {
      return _objectSpread$8({
        htmlFor: "".concat(props.id, "-input"),
        id: "".concat(props.id, "-label")
      }, rest);
    };

    var getListProps = function getListProps(rest) {
      return _objectSpread$8({
        role: 'listbox',
        'aria-labelledby': "".concat(props.id, "-label"),
        id: "".concat(props.id, "-list")
      }, rest);
    };

    var getPanelProps = function getPanelProps(rest) {
      return _objectSpread$8({
        onMouseDown: function onMouseDown(event) {
          // Prevents the `activeElement` from being changed to the panel so
          // that the blur event is not triggered, otherwise it closes the
          // panel.
          event.preventDefault();
        },
        onMouseLeave: function onMouseLeave() {
          store.dispatch('mouseleave', null);
        }
      }, rest);
    };

    var getItemProps = function getItemProps(providedProps) {
      var item = providedProps.item,
          source = providedProps.source,
          rest = _objectWithoutProperties$3(providedProps, ["item", "source"]);

      return _objectSpread$8({
        id: "".concat(props.id, "-item-").concat(item.__autocomplete_id),
        role: 'option',
        'aria-selected': store.getState().activeItemId === item.__autocomplete_id,
        onMouseMove: function onMouseMove(event) {
          if (item.__autocomplete_id === store.getState().activeItemId) {
            return;
          }

          store.dispatch('mousemove', item.__autocomplete_id);
          var activeItem = getActiveItem(store.getState());

          if (store.getState().activeItemId !== null && activeItem) {
            var _item = activeItem.item,
                itemInputValue = activeItem.itemInputValue,
                itemUrl = activeItem.itemUrl,
                _source = activeItem.source;

            _source.onActive(_objectSpread$8({
              event: event,
              item: _item,
              itemInputValue: itemInputValue,
              itemUrl: itemUrl,
              refresh: refresh,
              source: _source,
              state: store.getState()
            }, setters));
          }
        },
        onMouseDown: function onMouseDown(event) {
          // Prevents the `activeElement` from being changed to the item so it
          // can remain with the current `activeElement`.
          event.preventDefault();
        },
        onClick: function onClick(event) {
          var itemInputValue = source.getItemInputValue({
            item: item,
            state: store.getState()
          });
          var itemUrl = source.getItemUrl({
            item: item,
            state: store.getState()
          }); // If `getItemUrl` is provided, it means that the suggestion
          // is a link, not plain text that aims at updating the query.
          // We can therefore skip the state change because it will update
          // the `activeItemId`, resulting in a UI flash, especially
          // noticeable on mobile.

          var runPreCommand = itemUrl ? Promise.resolve() : onInput(_objectSpread$8({
            event: event,
            nextState: {
              isOpen: false
            },
            props: props,
            query: itemInputValue,
            refresh: refresh,
            store: store
          }, setters));
          runPreCommand.then(function () {
            source.onSelect(_objectSpread$8({
              event: event,
              item: item,
              itemInputValue: itemInputValue,
              itemUrl: itemUrl,
              refresh: refresh,
              source: source,
              state: store.getState()
            }, setters));
          });
        }
      }, rest);
    };

    return {
      getEnvironmentProps: getEnvironmentProps,
      getRootProps: getRootProps,
      getFormProps: getFormProps,
      getLabelProps: getLabelProps,
      getInputProps: getInputProps,
      getPanelProps: getPanelProps,
      getListProps: getListProps,
      getItemProps: getItemProps
    };
  }

  function getCompletion(_ref) {
    var state = _ref.state;

    if (state.isOpen === false || state.activeItemId === null) {
      return null;
    }

    var _ref2 = getActiveItem(state),
        itemInputValue = _ref2.itemInputValue;

    return itemInputValue || null;
  }

  function ownKeys$a(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$9(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$a(Object(source), true).forEach(function (key) {
          _defineProperty$a(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$a(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$a(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  var stateReducer = function stateReducer(state, action) {
    switch (action.type) {
      case 'setActiveItemId':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            activeItemId: action.payload
          });
        }

      case 'setQuery':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            query: action.payload,
            completion: null
          });
        }

      case 'setCollections':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            collections: action.payload
          });
        }

      case 'setIsOpen':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            isOpen: action.payload
          });
        }

      case 'setStatus':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            status: action.payload
          });
        }

      case 'setContext':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            context: _objectSpread$9(_objectSpread$9({}, state.context), action.payload)
          });
        }

      case 'ArrowDown':
        {
          var nextState = _objectSpread$9(_objectSpread$9({}, state), {}, {
            activeItemId: getNextActiveItemId(1, state.activeItemId, getItemsCount(state), action.props.defaultActiveItemId)
          });

          return _objectSpread$9(_objectSpread$9({}, nextState), {}, {
            completion: getCompletion({
              state: nextState
            })
          });
        }

      case 'ArrowUp':
        {
          var _nextState = _objectSpread$9(_objectSpread$9({}, state), {}, {
            activeItemId: getNextActiveItemId(-1, state.activeItemId, getItemsCount(state), action.props.defaultActiveItemId)
          });

          return _objectSpread$9(_objectSpread$9({}, _nextState), {}, {
            completion: getCompletion({
              state: _nextState
            })
          });
        }

      case 'Escape':
        {
          if (state.isOpen) {
            return _objectSpread$9(_objectSpread$9({}, state), {}, {
              isOpen: false,
              completion: null
            });
          }

          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            query: '',
            status: 'idle',
            collections: []
          });
        }

      case 'submit':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            activeItemId: null,
            isOpen: false,
            status: 'idle'
          });
        }

      case 'reset':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            activeItemId: // Since we open the panel on reset when openOnFocus=true
            // we need to restore the highlighted index to the defaultActiveItemId. (DocSearch use-case)
            // Since we close the panel when openOnFocus=false
            // we lose track of the highlighted index. (Query-suggestions use-case)
            action.props.openOnFocus === true ? action.props.defaultActiveItemId : null,
            status: 'idle',
            query: ''
          });
        }

      case 'focus':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            activeItemId: action.props.defaultActiveItemId,
            isOpen: (action.props.openOnFocus || Boolean(state.query)) && action.props.shouldPanelOpen({
              state: state
            })
          });
        }

      case 'blur':
        {
          if (action.props.debug) {
            return state;
          }

          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            isOpen: false,
            activeItemId: null
          });
        }

      case 'mousemove':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            activeItemId: action.payload
          });
        }

      case 'mouseleave':
        {
          return _objectSpread$9(_objectSpread$9({}, state), {}, {
            activeItemId: action.props.defaultActiveItemId
          });
        }

      default:
        invariant(false, "The reducer action ".concat(JSON.stringify(action.type), " is not supported."));
        return state;
    }
  };

  function ownKeys$b(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$a(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$b(Object(source), true).forEach(function (key) {
          _defineProperty$b(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$b(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$b(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  function createAutocomplete(options) {
    checkOptions(options);
    var subscribers = [];
    var props = getDefaultProps(options, subscribers);
    var store = createStore(stateReducer, props, onStoreStateChange);
    var setters = getAutocompleteSetters({
      store: store
    });
    var propGetters = getPropGetters(_objectSpread$a({
      props: props,
      refresh: refresh,
      store: store
    }, setters));

    function onStoreStateChange(_ref) {
      var prevState = _ref.prevState,
          state = _ref.state;
      props.onStateChange(_objectSpread$a({
        prevState: prevState,
        state: state,
        refresh: refresh
      }, setters));
    }

    function refresh() {
      return onInput(_objectSpread$a({
        event: new Event('input'),
        nextState: {
          isOpen: store.getState().isOpen
        },
        props: props,
        query: store.getState().query,
        refresh: refresh,
        store: store
      }, setters));
    }

    props.plugins.forEach(function (plugin) {
      var _plugin$subscribe;

      return (_plugin$subscribe = plugin.subscribe) === null || _plugin$subscribe === void 0 ? void 0 : _plugin$subscribe.call(plugin, _objectSpread$a(_objectSpread$a({}, setters), {}, {
        refresh: refresh,
        onSelect: function onSelect(fn) {
          subscribers.push({
            onSelect: fn
          });
        },
        onActive: function onActive(fn) {
          subscribers.push({
            onActive: fn
          });
        }
      }));
    });
    return _objectSpread$a(_objectSpread$a({
      refresh: refresh
    }, propGetters), setters);
  }

  var ClearIcon = function ClearIcon(_ref) {
    var environment = _ref.environment;
    var element = environment.document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    element.setAttribute('class', 'aa-ClearIcon');
    element.setAttribute('viewBox', '0 0 24 24');
    element.setAttribute('width', '18');
    element.setAttribute('height', '18');
    element.setAttribute('fill', 'currentColor');
    var path = environment.document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M5.293 6.707l5.293 5.293-5.293 5.293c-0.391 0.391-0.391 1.024 0 1.414s1.024 0.391 1.414 0l5.293-5.293 5.293 5.293c0.391 0.391 1.024 0.391 1.414 0s0.391-1.024 0-1.414l-5.293-5.293 5.293-5.293c0.391-0.391 0.391-1.024 0-1.414s-1.024-0.391-1.414 0l-5.293 5.293-5.293-5.293c-0.391-0.391-1.024-0.391-1.414 0s-0.391 1.024 0 1.414z');
    element.appendChild(path);
    return element;
  };

  function getHTMLElement(environment, value) {
    if (typeof value === 'string') {
      var element = environment.document.querySelector(value);
      invariant(element !== null, "The element ".concat(JSON.stringify(value), " is not in the document."));
      return element;
    }

    return value;
  }

  function mergeClassNames() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    return values.reduce(function (acc, current) {
      Object.keys(current).forEach(function (key) {
        var accValue = acc[key];
        var currentValue = current[key];

        if (accValue !== currentValue) {
          acc[key] = [accValue, currentValue].filter(Boolean).join(' ');
        }
      });
      return acc;
    }, {});
  }

  var isObject = function isObject(value) {
    return value && _typeof(value) === 'object';
  };

  function mergeDeep() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    return values.reduce(function (acc, current) {
      Object.keys(current).forEach(function (key) {
        var accValue = acc[key];
        var currentValue = current[key];

        if (Array.isArray(accValue) && Array.isArray(currentValue)) {
          acc[key] = accValue.concat.apply(accValue, _toConsumableArray(currentValue));
        } else if (isObject(accValue) && isObject(currentValue)) {
          acc[key] = mergeDeep(accValue, currentValue);
        } else {
          acc[key] = currentValue;
        }
      });
      return acc;
    }, {});
  }

  /* eslint-disable */

  /*
   * Taken from Preact
   *
   * See https://github.com/preactjs/preact/blob/6ab49d9020740127577bf4af66bf63f4af7f9fee/src/diff/props.js#L58-L151
   */
  function setStyle(style, key, value) {
    if (value === null) {
      style[key] = '';
    } else if (typeof value !== 'number') {
      style[key] = value;
    } else {
      style[key] = value + 'px';
    }
  }
  /**
   * Proxy an event to hooked event handlers
   */


  function eventProxy(event) {
    this._listeners[event.type](event);
  }
  /**
   * Set a property value on a DOM node
   */


  function setProperty(dom, name, value) {
    var useCapture;
    var nameLower;
    var oldValue = dom[name];

    if (name === 'style') {
      if (typeof value == 'string') {
        dom.style = value;
      } else {
        if (value === null) {
          dom.style = '';
        } else {
          for (name in value) {
            if (!oldValue || value[name] !== oldValue[name]) {
              setStyle(dom.style, name, value[name]);
            }
          }
        }
      }
    } // Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6
    else if (name[0] === 'o' && name[1] === 'n') {
        useCapture = name !== (name = name.replace(/Capture$/, ''));
        nameLower = name.toLowerCase();
        if (nameLower in dom) name = nameLower;
        name = name.slice(2);
        if (!dom._listeners) dom._listeners = {};
        dom._listeners[name] = value;

        if (value) {
          if (!oldValue) dom.addEventListener(name, eventProxy, useCapture);
        } else {
          dom.removeEventListener(name, eventProxy, useCapture);
        }
      } else if (name !== 'list' && name !== 'tagName' && // HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using
      // setAttribute
      name !== 'form' && name !== 'type' && name !== 'size' && name !== 'download' && name !== 'href' && name in dom) {
        dom[name] = value == null ? '' : value;
      } else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {
        if (value == null || value === false && // ARIA-attributes have a different notion of boolean values.
        // The value `false` is different from the attribute not
        // existing on the DOM, so we can't remove it. For non-boolean
        // ARIA-attributes we could treat false as a removal, but the
        // amount of exceptions would cost us too many bytes. On top of
        // that other VDOM frameworks also always stringify `false`.
        !/^ar/.test(name)) {
          dom.removeAttribute(name);
        } else {
          dom.setAttribute(name, value);
        }
      }
  }

  function getNormalizedName(name) {
    switch (name) {
      case 'onChange':
        return 'onInput';

      default:
        return name;
    }
  }

  function setProperties(dom, props) {
    for (var name in props) {
      setProperty(dom, getNormalizedName(name), props[name]);
    }
  }
  function setPropertiesWithoutEvents(dom, props) {
    for (var name in props) {
      if (!(name[0] === 'o' && name[1] === 'n')) {
        setProperty(dom, getNormalizedName(name), props[name]);
      }
    }
  }

  function getCreateDomElement(environment) {
    return function createDomElement(tagName, _ref) {
      var _ref$children = _ref.children,
          children = _ref$children === void 0 ? [] : _ref$children,
          props = _objectWithoutProperties(_ref, ["children"]);

      var element = environment.document.createElement(tagName);
      setProperties(element, props);
      element.append.apply(element, _toConsumableArray(children));
      return element;
    };
  }

  var Input = function Input(_ref) {
    var autocompleteScopeApi = _ref.autocompleteScopeApi,
        environment = _ref.environment,
        classNames = _ref.classNames,
        getInputProps = _ref.getInputProps,
        getInputPropsCore = _ref.getInputPropsCore,
        onDetachedEscape = _ref.onDetachedEscape,
        state = _ref.state,
        props = _objectWithoutProperties(_ref, ["autocompleteScopeApi", "environment", "classNames", "getInputProps", "getInputPropsCore", "onDetachedEscape", "state"]);

    var createDomElement = getCreateDomElement(environment);
    var element = createDomElement('input', props);
    var inputProps = getInputProps(_objectSpread2({
      state: state,
      props: getInputPropsCore({
        inputElement: element
      }),
      inputElement: element
    }, autocompleteScopeApi));
    setProperties(element, _objectSpread2(_objectSpread2({}, inputProps), {}, {
      onKeyDown: function onKeyDown(event) {
        if (onDetachedEscape && event.key === 'Escape') {
          event.preventDefault();
          onDetachedEscape();
          return;
        }

        inputProps.onKeyDown(event);
      }
    }));
    return element;
  };

  var LoadingIcon = function LoadingIcon(_ref) {
    var environment = _ref.environment;
    var element = environment.document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    element.setAttribute('class', 'aa-LoadingIcon');
    element.setAttribute('viewBox', '0 0 100 100');
    element.setAttribute('width', '20');
    element.setAttribute('height', '20');
    element.innerHTML = "<circle\n  cx=\"50\"\n  cy=\"50\"\n  fill=\"none\"\n  r=\"35\"\n  stroke=\"currentColor\"\n  stroke-dasharray=\"164.93361431346415 56.97787143782138\"\n  stroke-width=\"6\"\n>\n  <animateTransform\n    attributeName=\"transform\"\n    type=\"rotate\"\n    repeatCount=\"indefinite\"\n    dur=\"1s\"\n    values=\"0 50 50;90 50 50;180 50 50;360 50 50\"\n    keyTimes=\"0;0.40;0.65;1\"\n  />\n</circle>";
    return element;
  };

  var SearchIcon = function SearchIcon(_ref) {
    var environment = _ref.environment;
    var element = environment.document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    element.setAttribute('class', 'aa-SubmitIcon');
    element.setAttribute('viewBox', '0 0 24 24');
    element.setAttribute('width', '20');
    element.setAttribute('height', '20');
    element.setAttribute('fill', 'currentColor');
    var path = environment.document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M16.041 15.856c-0.034 0.026-0.067 0.055-0.099 0.087s-0.060 0.064-0.087 0.099c-1.258 1.213-2.969 1.958-4.855 1.958-1.933 0-3.682-0.782-4.95-2.050s-2.050-3.017-2.050-4.95 0.782-3.682 2.050-4.95 3.017-2.050 4.95-2.050 3.682 0.782 4.95 2.050 2.050 3.017 2.050 4.95c0 1.886-0.745 3.597-1.959 4.856zM21.707 20.293l-3.675-3.675c1.231-1.54 1.968-3.493 1.968-5.618 0-2.485-1.008-4.736-2.636-6.364s-3.879-2.636-6.364-2.636-4.736 1.008-6.364 2.636-2.636 3.879-2.636 6.364 1.008 4.736 2.636 6.364 3.879 2.636 6.364 2.636c2.125 0 4.078-0.737 5.618-1.968l3.675 3.675c0.391 0.391 1.024 0.391 1.414 0s0.391-1.024 0-1.414z');
    element.appendChild(path);
    return element;
  };

  function createAutocompleteDom(_ref) {
    var autocomplete = _ref.autocomplete,
        autocompleteScopeApi = _ref.autocompleteScopeApi,
        classNames = _ref.classNames,
        environment = _ref.environment,
        isDetached = _ref.isDetached,
        _ref$placeholder = _ref.placeholder,
        placeholder = _ref$placeholder === void 0 ? 'Search' : _ref$placeholder,
        propGetters = _ref.propGetters,
        setIsModalOpen = _ref.setIsModalOpen,
        state = _ref.state;
    var createDomElement = getCreateDomElement(environment);
    var rootProps = propGetters.getRootProps(_objectSpread2({
      state: state,
      props: autocomplete.getRootProps({})
    }, autocompleteScopeApi));
    var root = createDomElement('div', _objectSpread2({
      class: classNames.root
    }, rootProps));
    var detachedContainer = createDomElement('div', {
      class: classNames.detachedContainer,
      onMouseDown: function onMouseDown(event) {
        event.stopPropagation();
      }
    });
    var detachedOverlay = createDomElement('div', {
      class: classNames.detachedOverlay,
      children: [detachedContainer],
      onMouseDown: function onMouseDown() {
        setIsModalOpen(false);
        autocomplete.setIsOpen(false);
      }
    });
    var labelProps = propGetters.getLabelProps(_objectSpread2({
      state: state,
      props: autocomplete.getLabelProps({})
    }, autocompleteScopeApi));
    var submitButton = createDomElement('button', {
      class: classNames.submitButton,
      type: 'submit',
      title: 'Submit',
      children: [SearchIcon({
        environment: environment
      })]
    });
    var label = createDomElement('label', _objectSpread2({
      class: classNames.label,
      children: [submitButton]
    }, labelProps));
    var clearButton = createDomElement('button', {
      class: classNames.clearButton,
      type: 'reset',
      title: 'Clear',
      children: [ClearIcon({
        environment: environment
      })]
    });
    var loadingIndicator = createDomElement('div', {
      class: classNames.loadingIndicator,
      children: [LoadingIcon({
        environment: environment
      })]
    });
    var input = Input({
      class: classNames.input,
      environment: environment,
      state: state,
      getInputProps: propGetters.getInputProps,
      getInputPropsCore: autocomplete.getInputProps,
      autocompleteScopeApi: autocompleteScopeApi,
      onDetachedEscape: isDetached ? function () {
        autocomplete.setIsOpen(false);
        setIsModalOpen(false);
      } : undefined
    });
    var inputWrapperPrefix = createDomElement('div', {
      class: classNames.inputWrapperPrefix,
      children: [label, loadingIndicator]
    });
    var inputWrapperSuffix = createDomElement('div', {
      class: classNames.inputWrapperSuffix,
      children: [clearButton]
    });
    var inputWrapper = createDomElement('div', {
      class: classNames.inputWrapper,
      children: [input]
    });
    var formProps = propGetters.getFormProps(_objectSpread2({
      state: state,
      props: autocomplete.getFormProps({
        inputElement: input
      })
    }, autocompleteScopeApi));
    var form = createDomElement('form', _objectSpread2({
      class: classNames.form,
      children: [inputWrapperPrefix, inputWrapper, inputWrapperSuffix]
    }, formProps));
    var panelProps = propGetters.getPanelProps(_objectSpread2({
      state: state,
      props: autocomplete.getPanelProps({})
    }, autocompleteScopeApi));
    var panel = createDomElement('div', _objectSpread2({
      class: classNames.panel
    }, panelProps));

    if ("development" === 'test') {
      setProperties(panel, {
        'data-testid': 'panel'
      });
    }

    if (isDetached) {
      var detachedSearchButtonIcon = createDomElement('div', {
        class: classNames.detachedSearchButtonIcon,
        children: [SearchIcon({
          environment: environment
        })]
      });
      var detachedSearchButtonPlaceholder = createDomElement('div', {
        class: classNames.detachedSearchButtonPlaceholder,
        textContent: placeholder
      });
      var detachedSearchButton = createDomElement('button', {
        class: classNames.detachedSearchButton,
        onClick: function onClick(event) {
          event.preventDefault();
          setIsModalOpen(true);
        },
        children: [detachedSearchButtonIcon, detachedSearchButtonPlaceholder]
      });
      var detachedCancelButton = createDomElement('button', {
        class: classNames.detachedCancelButton,
        textContent: 'Cancel',
        onClick: function onClick() {
          autocomplete.setIsOpen(false);
          setIsModalOpen(false);
        }
      });
      var detachedFormContainer = createDomElement('div', {
        class: classNames.detachedFormContainer,
        children: [form, detachedCancelButton]
      });
      detachedContainer.appendChild(detachedFormContainer);
      root.appendChild(detachedSearchButton);
    } else {
      root.appendChild(form);
    }

    return {
      detachedContainer: detachedContainer,
      detachedOverlay: detachedOverlay,
      inputWrapper: inputWrapper,
      input: input,
      root: root,
      form: form,
      label: label,
      submitButton: submitButton,
      clearButton: clearButton,
      loadingIndicator: loadingIndicator,
      panel: panel
    };
  }

  function createEffectWrapper() {
    var effects = [];
    var cleanups = [];

    function runEffect(fn) {
      effects.push(fn);
      var effectCleanup = fn();
      cleanups.push(effectCleanup);
    }

    return {
      runEffect: runEffect,
      cleanupEffects: function cleanupEffects() {
        var currentCleanups = cleanups;
        cleanups = [];
        currentCleanups.forEach(function (cleanup) {
          cleanup();
        });
      },
      runEffects: function runEffects() {
        var currentEffects = effects;
        effects = [];
        currentEffects.forEach(function (effect) {
          runEffect(effect);
        });
      }
    };
  }

  function createReactiveWrapper() {
    var reactives = [];
    return {
      reactive: function reactive(value) {
        var current = value();
        var reactive = {
          _fn: value,
          _ref: {
            current: current
          },

          get value() {
            return this._ref.current;
          },

          set value(value) {
            this._ref.current = value;
          }

        };
        reactives.push(reactive);
        return reactive;
      },
      runReactives: function runReactives() {
        reactives.forEach(function (value) {
          value._ref.current = value._fn();
        });
      }
    };
  }

  var n,u,i,t,o,r={},f=[],e=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function c(n,l){for(var u in l)n[u]=l[u];return n}function s(n){var l=n.parentNode;l&&l.removeChild(n);}function a(n,l,u){var i,t,o,r=arguments,f={};for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return v(n,f,i,t,null)}function v(l,u,i,t,o){var r={type:l,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==o?++n.__v:o};return null!=n.vnode&&n.vnode(r),r}function y(n){return n.children}function p(n,l){this.props=n,this.context=l;}function d(n,l){if(null==l)return n.__?d(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?d(n):null}function _(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return _(n)}}function k(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!b.__r++||t!==n.debounceRendering)&&((t=n.debounceRendering)||i)(b);}function b(){for(var n;b.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=c({},t)).__v=t.__v+1,I(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?d(t):o,t.__h),T(u,t),t.__e!=o&&_(t)));});}function m(n,l,u,i,t,o,e,c,s,a){var h,p,_,k,b,m,w,A=i&&i.__k||f,P=A.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k||"bigint"==typeof k?v(null,k,null,null,k):Array.isArray(k)?v(y,{children:k},null,null,null):k.__b>0?v(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(_=A[h])||_&&k.key==_.key&&k.type===_.type)A[h]=void 0;else for(p=0;p<P;p++){if((_=A[p])&&k.key==_.key&&k.type===_.type){A[p]=void 0;break}_=null;}I(n,k,_=_||r,t,o,e,c,s,a),b=k.__e,(p=k.ref)&&_.ref!=p&&(w||(w=[]),_.ref&&w.push(_.ref,null,k),w.push(p,k.__c||b,k)),null!=b?(null==m&&(m=b),"function"==typeof k.type&&null!=k.__k&&k.__k===_.__k?k.__d=s=g(k,s,n):s=x(n,k,_,A,b,s),a||"option"!==u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&_.__e==s&&s.parentNode!=n&&(s=d(_));}for(u.__e=m,h=P;h--;)null!=A[h]&&("function"==typeof u.type&&null!=A[h].__e&&A[h].__e==u.__d&&(u.__d=d(i,h+1)),L(A[h],A[h]));if(w)for(h=0;h<w.length;h++)z(w[h],w[++h],w[++h]);}function g(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,l="function"==typeof t.type?g(t,l,u):x(u,t,t,n.__k,t.__e,l));return l}function x(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else {for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o;}return void 0!==r?r:t.nextSibling}function A(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||C(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||C(n,o,l[o],u[o],i);}function P(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||e.test(l)?u:u+"px";}function C(n,l,u,i,t){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||P(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||P(n.style,l,u[l]);}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?H:$,o):n.removeEventListener(l,o?H:$,o);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink[H:h]/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null!=u&&(!1!==u||"a"===l[0]&&"r"===l[1])?n.setAttribute(l,u):n.removeAttribute(l));}}function $(l){this.l[l.type+!1](n.event?n.event(l):l);}function H(l){this.l[l.type+!0](n.event?n.event(l):l);}function I(l,u,i,t,o,r,f,e,s){var a,v,h,d,_,k,b,g,w,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(s=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(g=u.props,w=(a=P.contextType)&&t[a.__c],x=a?w?w.props.value:a.__:t,i.__c?b=(v=u.__c=i.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(g,x):(u.__c=v=new p(g,x),v.constructor=P,v.render=M),w&&w.sub(v),v.props=g,v.state||(v.state={}),v.context=x,v.__n=t,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=c({},v.__s)),c(v.__s,P.getDerivedStateFromProps(g,v.__s))),d=v.props,_=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else {if(null==P.getDerivedStateFromProps&&g!==d&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(g,x),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(g,v.__s,x)||u.__v===i.__v){v.props=g,v.state=v.__s,u.__v!==i.__v&&(v.__d=!1),v.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u);}),v.__h.length&&f.push(v);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(g,v.__s,x),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(d,_,k);});}v.context=x,v.props=g,v.state=v.__s,(a=n.__r)&&a(u),v.__d=!1,v.__v=u,v.__P=l,a=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(t=c(c({},t),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(k=v.getSnapshotBeforeUpdate(d,_)),A=null!=a&&a.type===y&&null==a.key?a.props.children:a,m(l,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,s),v.base=u.__e,u.__h=null,v.__h.length&&f.push(v),b&&(v.__E=v.__=null),v.__e=!1;}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=j(i.__e,u,i,t,o,r,f,s);(a=n.diffed)&&a(u);}catch(l){u.__v=null,(s||null!=r)&&(u.__e=e,u.__h=!!s,r[r.indexOf(e)]=null),n.__e(l,u,i);}}function T(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u);});}catch(l){n.__e(l,u.__v);}});}function j(n,l,u,i,t,o,e,c){var a,v,h,y,p=u.props,d=l.props,_=l.type,k=0;if("svg"===_&&(t=!0),null!=o)for(;k<o.length;k++)if((a=o[k])&&(a===n||(_?a.localName==_:3==a.nodeType))){n=a,o[k]=null;break}if(null==n){if(null===_)return document.createTextNode(d);n=t?document.createElementNS("http://www.w3.org/2000/svg",_):document.createElement(_,d.is&&d),o=null,c=!1;}if(null===_)p===d||c&&n.data===d||(n.data=d);else {if(o=o&&f.slice.call(n.childNodes),v=(p=u.props||r).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,!c){if(null!=o)for(p={},y=0;y<n.attributes.length;y++)p[n.attributes[y].name]=n.attributes[y].value;(h||v)&&(h&&(v&&h.__html==v.__html||h.__html===n.innerHTML)||(n.innerHTML=h&&h.__html||""));}if(A(n,d,p,t,c),h)l.__k=[];else if(k=l.props.children,m(n,Array.isArray(k)?k:[k],l,u,i,t&&"foreignObject"!==_,o,e,n.firstChild,c),null!=o)for(k=o.length;k--;)null!=o[k]&&s(o[k]);c||("value"in d&&void 0!==(k=d.value)&&(k!==n.value||"progress"===_&&!k)&&C(n,"value",k,p.value,!1),"checked"in d&&void 0!==(k=d.checked)&&k!==n.checked&&C(n,"checked",k,p.checked,!1));}return n}function z(l,u,i){try{"function"==typeof l?l(u):l.current=u;}catch(l){n.__e(l,i);}}function L(l,u,i){var t,o,r;if(n.unmount&&n.unmount(l),(t=l.ref)&&(t.current&&t.current!==l.__e||z(t,null,u)),i||"function"==typeof l.type||(i=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(t=l.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(l){n.__e(l,u);}t.base=t.__P=null;}if(t=l.__k)for(r=0;r<t.length;r++)t[r]&&L(t[r],u,i);null!=o&&s(o);}function M(n,l,u){return this.constructor(n,u)}function N(l,u,i){var t,o,e;n.__&&n.__(l,u),o=(t="function"==typeof i)?null:i&&i.__k||u.__k,e=[],I(u,l=(!t&&i||u).__k=a(y,null,[l]),o||r,r,void 0!==u.ownerSVGElement,!t&&i?[i]:o?null:u.firstChild?f.slice.call(u.childNodes):null,e,!t&&i?i:o?o.__e:u.firstChild,t),T(e,l);}n={__e:function(n,l){for(var u,i,t;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return u.__E=u}catch(l){n=l;}throw n},__v:0},p.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=c({},this.state),"function"==typeof n&&(n=n(c({},u),this.props)),n&&c(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this));},p.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this));},p.prototype.render=y,u=[],i="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,b.__r=0,o=0;

  var HIGHLIGHT_PRE_TAG = '__aa-highlight__';
  var HIGHLIGHT_POST_TAG = '__/aa-highlight__';

  /**
   * Creates a data structure that allows to concatenate similar highlighting
   * parts in a single value.
   */

  function createAttributeSet() {
    var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var value = initialValue;
    return {
      get: function get() {
        return value;
      },
      add: function add(part) {
        var lastPart = value[value.length - 1];

        if ((lastPart === null || lastPart === void 0 ? void 0 : lastPart.isHighlighted) === part.isHighlighted) {
          value[value.length - 1] = {
            value: lastPart.value + part.value,
            isHighlighted: lastPart.isHighlighted
          };
        } else {
          value.push(part);
        }
      }
    };
  }

  function parseAttribute(_ref) {
    var highlightedValue = _ref.highlightedValue;
    var preTagParts = highlightedValue.split(HIGHLIGHT_PRE_TAG);
    var firstValue = preTagParts.shift();
    var parts = createAttributeSet(firstValue ? [{
      value: firstValue,
      isHighlighted: false
    }] : []);
    preTagParts.forEach(function (part) {
      var postTagParts = part.split(HIGHLIGHT_POST_TAG);
      parts.add({
        value: postTagParts[0],
        isHighlighted: true
      });

      if (postTagParts[1] !== '') {
        parts.add({
          value: postTagParts[1],
          isHighlighted: false
        });
      }
    });
    return parts.get();
  }

  function _toConsumableArray$3(arr) {
    return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread$3();
  }

  function _nonIterableSpread$3() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$3(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
  }

  function _iterableToArray$3(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$3(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$3(arr);
  }

  function _arrayLikeToArray$3(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
  function parseAlgoliaHitHighlight(_ref) {
    var hit = _ref.hit,
        attribute = _ref.attribute;
    var path = Array.isArray(attribute) ? attribute : [attribute];
    var highlightedValue = getAttributeValueByPath(hit, ['_highlightResult'].concat(_toConsumableArray$3(path), ['value']));

    if (typeof highlightedValue !== 'string') {
       "development" !== 'production' ? warn(false, "The attribute \"".concat(path.join('.'), "\" described by the path ").concat(JSON.stringify(path), " does not exist on the hit. Did you set it in `attributesToHighlight`?") + '\nSee https://www.algolia.com/doc/api-reference/api-parameters/attributesToHighlight/') : void 0 ;
      highlightedValue = getAttributeValueByPath(hit, path) || '';
    }

    return parseAttribute({
      highlightedValue: highlightedValue
    });
  }

  var htmlEscapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };
  var hasAlphanumeric = new RegExp(/\w/i);
  var regexEscapedHtml = /&(amp|quot|lt|gt|#39);/g;
  var regexHasEscapedHtml = RegExp(regexEscapedHtml.source);

  function unescape(value) {
    return value && regexHasEscapedHtml.test(value) ? value.replace(regexEscapedHtml, function (character) {
      return htmlEscapes[character];
    }) : value;
  }

  function isPartHighlighted(parts, i) {
    var _parts, _parts2;

    var current = parts[i];
    var isNextHighlighted = ((_parts = parts[i + 1]) === null || _parts === void 0 ? void 0 : _parts.isHighlighted) || true;
    var isPreviousHighlighted = ((_parts2 = parts[i - 1]) === null || _parts2 === void 0 ? void 0 : _parts2.isHighlighted) || true;

    if (!hasAlphanumeric.test(unescape(current.value)) && isPreviousHighlighted === isNextHighlighted) {
      return isPreviousHighlighted;
    }

    return current.isHighlighted;
  }

  function ownKeys$c(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$b(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$c(Object(source), true).forEach(function (key) {
          _defineProperty$c(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$c(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$c(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  function reverseHighlightedParts(parts) {
    // We don't want to highlight the whole word when no parts match.
    if (!parts.some(function (part) {
      return part.isHighlighted;
    })) {
      return parts.map(function (part) {
        return _objectSpread$b(_objectSpread$b({}, part), {}, {
          isHighlighted: false
        });
      });
    }

    return parts.map(function (part, i) {
      return _objectSpread$b(_objectSpread$b({}, part), {}, {
        isHighlighted: !isPartHighlighted(parts, i)
      });
    });
  }

  function parseAlgoliaHitReverseHighlight(props) {
    return reverseHighlightedParts(parseAlgoliaHitHighlight(props));
  }

  function _toConsumableArray$4(arr) {
    return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread$4();
  }

  function _nonIterableSpread$4() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$4(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
  }

  function _iterableToArray$4(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$4(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$4(arr);
  }

  function _arrayLikeToArray$4(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
  function parseAlgoliaHitSnippet(_ref) {
    var hit = _ref.hit,
        attribute = _ref.attribute;
    var path = Array.isArray(attribute) ? attribute : [attribute];
    var highlightedValue = getAttributeValueByPath(hit, ['_snippetResult'].concat(_toConsumableArray$4(path), ['value']));

    if (typeof highlightedValue !== 'string') {
       "development" !== 'production' ? warn(false, "The attribute \"".concat(path.join('.'), "\" described by the path ").concat(JSON.stringify(path), " does not exist on the hit. Did you set it in `attributesToSnippet`?") + '\nSee https://www.algolia.com/doc/api-reference/api-parameters/attributesToSnippet/') : void 0 ;
      highlightedValue = getAttributeValueByPath(hit, path) || '';
    }

    return parseAttribute({
      highlightedValue: highlightedValue
    });
  }

  function parseAlgoliaHitReverseSnippet(props) {
    return reverseHighlightedParts(parseAlgoliaHitSnippet(props));
  }

  function ownKeys$d(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$c(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$d(Object(source), true).forEach(function (key) {
          _defineProperty$d(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$d(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$d(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function createRequester(fetcher) {
    function execute(fetcherParams) {
      return fetcher({
        searchClient: fetcherParams.searchClient,
        queries: fetcherParams.requests.map(function (x) {
          return x.query;
        })
      }).then(function (responses) {
        return responses.map(function (response, index) {
          var _fetcherParams$reques = fetcherParams.requests[index],
              sourceId = _fetcherParams$reques.sourceId,
              transformResponse = _fetcherParams$reques.transformResponse;
          return {
            items: response,
            sourceId: sourceId,
            transformResponse: transformResponse
          };
        });
      });
    }

    return function createSpecifiedRequester(requesterParams) {
      return function requester(requestParams) {
        return _objectSpread$c(_objectSpread$c({
          execute: execute
        }, requesterParams), requestParams);
      };
    };
  }

  var version = '1.0.1';

  function ownKeys$e(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$d(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$e(Object(source), true).forEach(function (key) {
          _defineProperty$e(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$e(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$e(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectWithoutProperties$4(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$4(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose$4(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _toConsumableArray$5(arr) {
    return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread$5();
  }

  function _nonIterableSpread$5() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray$5(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
  }

  function _iterableToArray$5(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _arrayWithoutHoles$5(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$5(arr);
  }

  function _arrayLikeToArray$5(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
  function fetchAlgoliaResults(_ref) {
    var searchClient = _ref.searchClient,
        queries = _ref.queries,
        _ref$userAgents = _ref.userAgents,
        userAgents = _ref$userAgents === void 0 ? [] : _ref$userAgents;

    if (typeof searchClient.addAlgoliaAgent === 'function') {
      var algoliaAgents = [{
        segment: 'autocomplete-core',
        version: version
      }].concat(_toConsumableArray$5(userAgents));
      algoliaAgents.forEach(function (_ref2) {
        var segment = _ref2.segment,
            version = _ref2.version;
        searchClient.addAlgoliaAgent(segment, version);
      });
    }

    return searchClient.search(queries.map(function (searchParameters) {
      var params = searchParameters.params,
          headers = _objectWithoutProperties$4(searchParameters, ["params"]);

      return _objectSpread$d(_objectSpread$d({}, headers), {}, {
        params: _objectSpread$d({
          hitsPerPage: 5,
          highlightPreTag: HIGHLIGHT_PRE_TAG,
          highlightPostTag: HIGHLIGHT_POST_TAG
        }, params)
      });
    })).then(function (response) {
      return response.results;
    });
  }

  function createHighlightComponent(_ref) {
    var createElement = _ref.createElement,
        Fragment = _ref.Fragment;
    return function Highlight(_ref2) {
      var hit = _ref2.hit,
          attribute = _ref2.attribute,
          _ref2$tagName = _ref2.tagName,
          tagName = _ref2$tagName === void 0 ? 'mark' : _ref2$tagName;
      return createElement(Fragment, {}, parseAlgoliaHitHighlight({
        hit: hit,
        attribute: attribute
      }).map(function (x, index) {
        return x.isHighlighted ? createElement(tagName, {
          key: index
        }, x.value) : x.value;
      }));
    };
  }

  function createReverseHighlightComponent(_ref) {
    var createElement = _ref.createElement,
        Fragment = _ref.Fragment;
    return function ReverseHighlight(_ref2) {
      var hit = _ref2.hit,
          attribute = _ref2.attribute,
          _ref2$tagName = _ref2.tagName,
          tagName = _ref2$tagName === void 0 ? 'mark' : _ref2$tagName;
      return createElement(Fragment, {}, parseAlgoliaHitReverseHighlight({
        hit: hit,
        attribute: attribute
      }).map(function (x, index) {
        return x.isHighlighted ? createElement(tagName, {
          key: index
        }, x.value) : x.value;
      }));
    };
  }

  function createReverseSnippetComponent(_ref) {
    var createElement = _ref.createElement,
        Fragment = _ref.Fragment;
    return function ReverseSnippet(_ref2) {
      var hit = _ref2.hit,
          attribute = _ref2.attribute,
          _ref2$tagName = _ref2.tagName,
          tagName = _ref2$tagName === void 0 ? 'mark' : _ref2$tagName;
      return createElement(Fragment, {}, parseAlgoliaHitReverseSnippet({
        hit: hit,
        attribute: attribute
      }).map(function (x, index) {
        return x.isHighlighted ? createElement(tagName, {
          key: index
        }, x.value) : x.value;
      }));
    };
  }

  function createSnippetComponent(_ref) {
    var createElement = _ref.createElement,
        Fragment = _ref.Fragment;
    return function Snippet(_ref2) {
      var hit = _ref2.hit,
          attribute = _ref2.attribute,
          _ref2$tagName = _ref2.tagName,
          tagName = _ref2$tagName === void 0 ? 'mark' : _ref2$tagName;
      return createElement(Fragment, {}, parseAlgoliaHitSnippet({
        hit: hit,
        attribute: attribute
      }).map(function (x, index) {
        return x.isHighlighted ? createElement(tagName, {
          key: index
        }, x.value) : x.value;
      }));
    };
  }

  var defaultClassNames = {
    clearButton: 'aa-ClearButton',
    detachedCancelButton: 'aa-DetachedCancelButton',
    detachedContainer: 'aa-DetachedContainer',
    detachedFormContainer: 'aa-DetachedFormContainer',
    detachedOverlay: 'aa-DetachedOverlay',
    detachedSearchButton: 'aa-DetachedSearchButton',
    detachedSearchButtonIcon: 'aa-DetachedSearchButtonIcon',
    detachedSearchButtonPlaceholder: 'aa-DetachedSearchButtonPlaceholder',
    form: 'aa-Form',
    input: 'aa-Input',
    inputWrapper: 'aa-InputWrapper',
    inputWrapperPrefix: 'aa-InputWrapperPrefix',
    inputWrapperSuffix: 'aa-InputWrapperSuffix',
    item: 'aa-Item',
    label: 'aa-Label',
    list: 'aa-List',
    loadingIndicator: 'aa-LoadingIndicator',
    panel: 'aa-Panel',
    panelLayout: 'aa-PanelLayout',
    root: 'aa-Autocomplete',
    source: 'aa-Source',
    sourceFooter: 'aa-SourceFooter',
    sourceHeader: 'aa-SourceHeader',
    sourceNoResults: 'aa-SourceNoResults',
    submitButton: 'aa-SubmitButton'
  };

  var defaultRender = function defaultRender(_ref, root) {
    var children = _ref.children;
    N(children, root);
  };

  var defaultRenderer = {
    createElement: a,
    Fragment: y
  };
  function getDefaultOptions(options) {
    var _core$id;

    var classNames = options.classNames,
        container = options.container,
        getEnvironmentProps = options.getEnvironmentProps,
        getFormProps = options.getFormProps,
        getInputProps = options.getInputProps,
        getItemProps = options.getItemProps,
        getLabelProps = options.getLabelProps,
        getListProps = options.getListProps,
        getPanelProps = options.getPanelProps,
        getRootProps = options.getRootProps,
        panelContainer = options.panelContainer,
        panelPlacement = options.panelPlacement,
        render = options.render,
        renderNoResults = options.renderNoResults,
        renderer = options.renderer,
        detachedMediaQuery = options.detachedMediaQuery,
        components = options.components,
        core = _objectWithoutProperties(options, ["classNames", "container", "getEnvironmentProps", "getFormProps", "getInputProps", "getItemProps", "getLabelProps", "getListProps", "getPanelProps", "getRootProps", "panelContainer", "panelPlacement", "render", "renderNoResults", "renderer", "detachedMediaQuery", "components"]);
    /* eslint-disable no-restricted-globals */


    var environment = typeof window !== 'undefined' ? window : {};
    /* eslint-enable no-restricted-globals */

    var containerElement = getHTMLElement(environment, container);
    invariant(containerElement.tagName !== 'INPUT', 'The `container` option does not support `input` elements. You need to change the container to a `div`.');
    var defaultedRenderer = renderer !== null && renderer !== void 0 ? renderer : defaultRenderer;
    var defaultComponents = {
      Highlight: createHighlightComponent(defaultedRenderer),
      ReverseHighlight: createReverseHighlightComponent(defaultedRenderer),
      ReverseSnippet: createReverseSnippetComponent(defaultedRenderer),
      Snippet: createSnippetComponent(defaultedRenderer)
    };
    return {
      renderer: {
        classNames: mergeClassNames(defaultClassNames, classNames !== null && classNames !== void 0 ? classNames : {}),
        container: containerElement,
        getEnvironmentProps: getEnvironmentProps !== null && getEnvironmentProps !== void 0 ? getEnvironmentProps : function (_ref2) {
          var props = _ref2.props;
          return props;
        },
        getFormProps: getFormProps !== null && getFormProps !== void 0 ? getFormProps : function (_ref3) {
          var props = _ref3.props;
          return props;
        },
        getInputProps: getInputProps !== null && getInputProps !== void 0 ? getInputProps : function (_ref4) {
          var props = _ref4.props;
          return props;
        },
        getItemProps: getItemProps !== null && getItemProps !== void 0 ? getItemProps : function (_ref5) {
          var props = _ref5.props;
          return props;
        },
        getLabelProps: getLabelProps !== null && getLabelProps !== void 0 ? getLabelProps : function (_ref6) {
          var props = _ref6.props;
          return props;
        },
        getListProps: getListProps !== null && getListProps !== void 0 ? getListProps : function (_ref7) {
          var props = _ref7.props;
          return props;
        },
        getPanelProps: getPanelProps !== null && getPanelProps !== void 0 ? getPanelProps : function (_ref8) {
          var props = _ref8.props;
          return props;
        },
        getRootProps: getRootProps !== null && getRootProps !== void 0 ? getRootProps : function (_ref9) {
          var props = _ref9.props;
          return props;
        },
        panelContainer: panelContainer ? getHTMLElement(environment, panelContainer) : environment.document.body,
        panelPlacement: panelPlacement !== null && panelPlacement !== void 0 ? panelPlacement : 'input-wrapper-width',
        render: render !== null && render !== void 0 ? render : defaultRender,
        renderNoResults: renderNoResults,
        renderer: defaultedRenderer,
        detachedMediaQuery: detachedMediaQuery !== null && detachedMediaQuery !== void 0 ? detachedMediaQuery : getComputedStyle(environment.document.documentElement).getPropertyValue('--aa-detached-media-query'),
        components: _objectSpread2(_objectSpread2({}, defaultComponents), components)
      },
      core: _objectSpread2(_objectSpread2({}, core), {}, {
        id: (_core$id = core.id) !== null && _core$id !== void 0 ? _core$id : generateAutocompleteId(),
        environment: environment
      })
    };
  }

  function getPanelPlacementStyle(_ref) {
    var panelPlacement = _ref.panelPlacement,
        container = _ref.container,
        form = _ref.form,
        environment = _ref.environment;
    var containerRect = container.getBoundingClientRect();
    var top = containerRect.top + containerRect.height;

    switch (panelPlacement) {
      case 'start':
        {
          return {
            top: top,
            left: containerRect.left
          };
        }

      case 'end':
        {
          return {
            top: top,
            right: environment.document.documentElement.clientWidth - (containerRect.left + containerRect.width)
          };
        }

      case 'full-width':
        {
          return {
            top: top,
            left: 0,
            right: 0,
            width: 'unset',
            maxWidth: 'unset'
          };
        }

      case 'input-wrapper-width':
        {
          var formRect = form.getBoundingClientRect();
          return {
            top: top,
            left: formRect.left,
            right: environment.document.documentElement.clientWidth - (formRect.left + formRect.width),
            width: 'unset',
            maxWidth: 'unset'
          };
        }

      default:
        {
          throw new Error("[Autocomplete] The `panelPlacement` value ".concat(JSON.stringify(panelPlacement), " is not valid."));
        }
    }
  }

  function renderSearchBox(_ref) {
    var autocomplete = _ref.autocomplete,
        autocompleteScopeApi = _ref.autocompleteScopeApi,
        dom = _ref.dom,
        propGetters = _ref.propGetters,
        state = _ref.state;
    setPropertiesWithoutEvents(dom.root, propGetters.getRootProps(_objectSpread2({
      state: state,
      props: autocomplete.getRootProps({})
    }, autocompleteScopeApi)));
    setPropertiesWithoutEvents(dom.input, propGetters.getInputProps(_objectSpread2({
      state: state,
      props: autocomplete.getInputProps({
        inputElement: dom.input
      }),
      inputElement: dom.input
    }, autocompleteScopeApi)));
    setProperties(dom.label, {
      hidden: state.status === 'stalled'
    });
    setProperties(dom.loadingIndicator, {
      hidden: state.status !== 'stalled'
    });
    setProperties(dom.clearButton, {
      hidden: !state.query
    });
  }
  function renderPanel(render, _ref2) {
    var autocomplete = _ref2.autocomplete,
        autocompleteScopeApi = _ref2.autocompleteScopeApi,
        classNames = _ref2.classNames,
        createElement = _ref2.createElement,
        dom = _ref2.dom,
        Fragment = _ref2.Fragment,
        panelContainer = _ref2.panelContainer,
        propGetters = _ref2.propGetters,
        state = _ref2.state,
        components = _ref2.components;

    if (!state.isOpen) {
      if (panelContainer.contains(dom.panel)) {
        panelContainer.removeChild(dom.panel);
      }

      return;
    } // We add the panel element to the DOM when it's not yet appended and that the
    // items are fetched.


    if (!panelContainer.contains(dom.panel) && state.status !== 'loading') {
      panelContainer.appendChild(dom.panel);
    }

    dom.panel.classList.toggle('aa-Panel--stalled', state.status === 'stalled');
    var sections = state.collections.map(function (_ref3, sourceIndex) {
      var source = _ref3.source,
          items = _ref3.items;
      return createElement("section", {
        key: sourceIndex,
        className: classNames.source,
        "data-autocomplete-source-id": source.sourceId
      }, source.templates.header && createElement("div", {
        className: classNames.sourceHeader
      }, source.templates.header({
        components: components,
        createElement: createElement,
        Fragment: Fragment,
        items: items,
        source: source,
        state: state
      })), source.templates.noResults && items.length === 0 ? createElement("div", {
        className: classNames.sourceNoResults
      }, source.templates.noResults({
        components: components,
        createElement: createElement,
        Fragment: Fragment,
        source: source,
        state: state
      })) : createElement("ul", _extends({
        className: classNames.list
      }, propGetters.getListProps(_objectSpread2({
        state: state,
        props: autocomplete.getListProps({})
      }, autocompleteScopeApi))), items.map(function (item) {
        var itemProps = autocomplete.getItemProps({
          item: item,
          source: source
        });
        return createElement("li", _extends({
          key: itemProps.id,
          className: classNames.item
        }, propGetters.getItemProps(_objectSpread2({
          state: state,
          props: itemProps
        }, autocompleteScopeApi))), source.templates.item({
          components: components,
          createElement: createElement,
          Fragment: Fragment,
          item: item,
          state: state
        }));
      })), source.templates.footer && createElement("div", {
        className: classNames.sourceFooter
      }, source.templates.footer({
        components: components,
        createElement: createElement,
        Fragment: Fragment,
        items: items,
        source: source,
        state: state
      })));
    });
    var children = createElement(Fragment, null, createElement("div", {
      className: "aa-PanelLayout aa-Panel--scrollable"
    }, sections), createElement("div", {
      className: "aa-GradientBottom"
    }));
    var elements = sections.reduce(function (acc, current) {
      acc[current.props['data-autocomplete-source-id']] = current;
      return acc;
    }, {});
    render({
      children: children,
      state: state,
      sections: sections,
      elements: elements,
      createElement: createElement,
      Fragment: Fragment,
      components: components
    }, dom.panel);
  }

  function autocomplete(options) {
    var _createEffectWrapper = createEffectWrapper(),
        runEffect = _createEffectWrapper.runEffect,
        cleanupEffects = _createEffectWrapper.cleanupEffects,
        runEffects = _createEffectWrapper.runEffects;

    var _createReactiveWrappe = createReactiveWrapper(),
        reactive = _createReactiveWrappe.reactive,
        runReactives = _createReactiveWrappe.runReactives;

    var hasNoResultsSourceTemplateRef = createRef(false);
    var optionsRef = createRef(options);
    var onStateChangeRef = createRef(undefined);
    var props = reactive(function () {
      return getDefaultOptions(optionsRef.current);
    });
    var isDetached = reactive(function () {
      return props.value.core.environment.matchMedia(props.value.renderer.detachedMediaQuery).matches;
    });
    var autocomplete = reactive(function () {
      return createAutocomplete(_objectSpread2(_objectSpread2({}, props.value.core), {}, {
        onStateChange: function onStateChange(params) {
          var _onStateChangeRef$cur, _props$value$core$onS, _props$value$core;

          hasNoResultsSourceTemplateRef.current = params.state.collections.some(function (collection) {
            return collection.source.templates.noResults;
          });
          (_onStateChangeRef$cur = onStateChangeRef.current) === null || _onStateChangeRef$cur === void 0 ? void 0 : _onStateChangeRef$cur.call(onStateChangeRef, params);
          (_props$value$core$onS = (_props$value$core = props.value.core).onStateChange) === null || _props$value$core$onS === void 0 ? void 0 : _props$value$core$onS.call(_props$value$core, params);
        },
        shouldPanelOpen: optionsRef.current.shouldPanelOpen || function (_ref) {
          var state = _ref.state;

          if (isDetached.value) {
            return true;
          }

          var hasItems = getItemsCount(state) > 0;

          if (!props.value.core.openOnFocus && !state.query) {
            return hasItems;
          }

          var hasNoResultsTemplate = Boolean(hasNoResultsSourceTemplateRef.current || props.value.renderer.renderNoResults);
          return !hasItems && hasNoResultsTemplate || hasItems;
        }
      }));
    });
    var lastStateRef = createRef(_objectSpread2({
      collections: [],
      completion: null,
      context: {},
      isOpen: false,
      query: '',
      activeItemId: null,
      status: 'idle'
    }, props.value.core.initialState));
    var propGetters = {
      getEnvironmentProps: props.value.renderer.getEnvironmentProps,
      getFormProps: props.value.renderer.getFormProps,
      getInputProps: props.value.renderer.getInputProps,
      getItemProps: props.value.renderer.getItemProps,
      getLabelProps: props.value.renderer.getLabelProps,
      getListProps: props.value.renderer.getListProps,
      getPanelProps: props.value.renderer.getPanelProps,
      getRootProps: props.value.renderer.getRootProps
    };
    var autocompleteScopeApi = {
      setActiveItemId: autocomplete.value.setActiveItemId,
      setQuery: autocomplete.value.setQuery,
      setCollections: autocomplete.value.setCollections,
      setIsOpen: autocomplete.value.setIsOpen,
      setStatus: autocomplete.value.setStatus,
      setContext: autocomplete.value.setContext,
      refresh: autocomplete.value.refresh
    };
    var dom = reactive(function () {
      return createAutocompleteDom({
        autocomplete: autocomplete.value,
        autocompleteScopeApi: autocompleteScopeApi,
        classNames: props.value.renderer.classNames,
        environment: props.value.core.environment,
        isDetached: isDetached.value,
        placeholder: props.value.core.placeholder,
        propGetters: propGetters,
        setIsModalOpen: setIsModalOpen,
        state: lastStateRef.current
      });
    });

    function setPanelPosition() {
      setProperties(dom.value.panel, {
        style: isDetached.value ? {} : getPanelPlacementStyle({
          panelPlacement: props.value.renderer.panelPlacement,
          container: dom.value.root,
          form: dom.value.form,
          environment: props.value.core.environment
        })
      });
    }

    function scheduleRender(state) {
      lastStateRef.current = state;
      var renderProps = {
        autocomplete: autocomplete.value,
        autocompleteScopeApi: autocompleteScopeApi,
        classNames: props.value.renderer.classNames,
        components: props.value.renderer.components,
        container: props.value.renderer.container,
        createElement: props.value.renderer.renderer.createElement,
        dom: dom.value,
        Fragment: props.value.renderer.renderer.Fragment,
        panelContainer: isDetached.value ? dom.value.detachedContainer : props.value.renderer.panelContainer,
        propGetters: propGetters,
        state: lastStateRef.current
      };
      var render = !getItemsCount(state) && !hasNoResultsSourceTemplateRef.current && props.value.renderer.renderNoResults || props.value.renderer.render;
      renderSearchBox(renderProps);
      renderPanel(render, renderProps);
    }

    runEffect(function () {
      var environmentProps = autocomplete.value.getEnvironmentProps({
        formElement: dom.value.form,
        panelElement: dom.value.panel,
        inputElement: dom.value.input
      });
      setProperties(props.value.core.environment, environmentProps);
      return function () {
        setProperties(props.value.core.environment, Object.keys(environmentProps).reduce(function (acc, key) {
          return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, key, undefined));
        }, {}));
      };
    });
    runEffect(function () {
      var panelContainerElement = isDetached.value ? props.value.core.environment.document.body : props.value.renderer.panelContainer;
      var panelElement = isDetached.value ? dom.value.detachedOverlay : dom.value.panel;

      if (isDetached.value && lastStateRef.current.isOpen) {
        setIsModalOpen(true);
      }

      scheduleRender(lastStateRef.current);
      return function () {
        if (panelContainerElement.contains(panelElement)) {
          panelContainerElement.removeChild(panelElement);
        }
      };
    });
    runEffect(function () {
      var containerElement = props.value.renderer.container;
      containerElement.appendChild(dom.value.root);
      return function () {
        containerElement.removeChild(dom.value.root);
      };
    });
    runEffect(function () {
      var debouncedRender = debounce(function (_ref2) {
        var state = _ref2.state;
        scheduleRender(state);
      }, 0);

      onStateChangeRef.current = function (_ref3) {
        var state = _ref3.state,
            prevState = _ref3.prevState;

        if (isDetached.value && prevState.isOpen !== state.isOpen) {
          setIsModalOpen(state.isOpen);
        } // The outer DOM might have changed since the last time the panel was
        // positioned. The layout might have shifted vertically for instance.
        // It's therefore safer to re-calculate the panel position before opening
        // it again.


        if (!isDetached.value && state.isOpen && !prevState.isOpen) {
          setPanelPosition();
        } // We scroll to the top of the panel whenever the query changes (i.e. new
        // results come in) so that users don't have to.


        if (state.query !== prevState.query) {
          var scrollablePanels = props.value.core.environment.document.querySelectorAll('.aa-Panel--scrollable');
          scrollablePanels.forEach(function (scrollablePanel) {
            if (scrollablePanel.scrollTop !== 0) {
              scrollablePanel.scrollTop = 0;
            }
          });
        }

        debouncedRender({
          state: state
        });
      };

      return function () {
        onStateChangeRef.current = undefined;
      };
    });
    runEffect(function () {
      var onResize = debounce(function () {
        var previousIsDetached = isDetached.value;
        isDetached.value = props.value.core.environment.matchMedia(props.value.renderer.detachedMediaQuery).matches;

        if (previousIsDetached !== isDetached.value) {
          update({});
        } else {
          requestAnimationFrame(setPanelPosition);
        }
      }, 20);
      props.value.core.environment.addEventListener('resize', onResize);
      return function () {
        props.value.core.environment.removeEventListener('resize', onResize);
      };
    });
    runEffect(function () {
      if (!isDetached.value) {
        return function () {};
      }

      function toggleModalClassname(isActive) {
        dom.value.detachedContainer.classList.toggle('aa-DetachedContainer--modal', isActive);
      }

      function onChange(event) {
        toggleModalClassname(event.matches);
      }

      var isModalDetachedMql = props.value.core.environment.matchMedia(getComputedStyle(props.value.core.environment.document.documentElement).getPropertyValue('--aa-detached-modal-media-query'));
      toggleModalClassname(isModalDetachedMql.matches);
      isModalDetachedMql.addEventListener('change', onChange);
      return function () {
        isModalDetachedMql.removeEventListener('change', onChange);
      };
    });
    runEffect(function () {
      requestAnimationFrame(setPanelPosition);
      return function () {};
    });

    function destroy() {
      cleanupEffects();
    }

    function update() {
      var updatedOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      cleanupEffects();
      optionsRef.current = mergeDeep(props.value.renderer, props.value.core, {
        initialState: lastStateRef.current
      }, updatedOptions);
      runReactives();
      runEffects();
      autocomplete.value.refresh().then(function () {
        scheduleRender(lastStateRef.current);
      });
    }

    function setIsModalOpen(value) {
      requestAnimationFrame(function () {
        var prevValue = props.value.core.environment.document.body.contains(dom.value.detachedOverlay);

        if (value === prevValue) {
          return;
        }

        if (value) {
          props.value.core.environment.document.body.appendChild(dom.value.detachedOverlay);
          props.value.core.environment.document.body.classList.add('aa-Detached');
          dom.value.input.focus();
        } else {
          props.value.core.environment.document.body.removeChild(dom.value.detachedOverlay);
          props.value.core.environment.document.body.classList.remove('aa-Detached');
          autocomplete.value.setQuery('');
          autocomplete.value.refresh();
        }
      });
    }

    return _objectSpread2(_objectSpread2({}, autocompleteScopeApi), {}, {
      update: update,
      destroy: destroy
    });
  }

  var version$1 = '1.0.1';

  var createAlgoliaRequester = createRequester(function (params) {
    return fetchAlgoliaResults(_objectSpread2(_objectSpread2({}, params), {}, {
      userAgents: [{
        segment: 'autocomplete-js',
        version: version$1
      }]
    }));
  });

  /**
   * Retrieves Algolia facet hits from multiple indices.
   */

  function getAlgoliaFacets(requestParams) {
    var requester = createAlgoliaRequester({
      transformResponse: function transformResponse(response) {
        return response.facetHits;
      }
    });
    var queries = requestParams.queries.map(function (query) {
      return _objectSpread2(_objectSpread2({}, query), {}, {
        type: 'facet'
      });
    });
    return requester(_objectSpread2(_objectSpread2({}, requestParams), {}, {
      queries: queries
    }));
  }

  /**
   * Retrieves Algolia results from multiple indices.
   */

  var getAlgoliaResults = createAlgoliaRequester({
    transformResponse: function transformResponse(response) {
      return response.hits;
    }
  });

  exports.autocomplete = autocomplete;
  exports.getAlgoliaFacets = getAlgoliaFacets;
  exports.getAlgoliaResults = getAlgoliaResults;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.development.js.map
