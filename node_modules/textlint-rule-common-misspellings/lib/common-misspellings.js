/* textlint-rule-common-misspellings
 * Copyright (C) 2016  IRIDE Monad <iride.monad@gmail.com>
 *
 * This file is part of `textlint-rule-common-misspellings`.
 *
 * `misspellings` is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * `misspellings` is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with `misspellings`.  If not, see <http://www.gnu.org/licenses/>.
 */

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _textlintRuleHelper = require("textlint-rule-helper");

var _misspellings = require("misspellings");

var _misspellings2 = _interopRequireDefault(_misspellings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_OPTIONS = {
  // Misspellings to be ignored
  "ignore": []
};

function reporter(context) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var opts = Object.assign({}, DEFAULT_OPTIONS, options);

  var ignoreDict = {};
  (opts["ignore"] || []).forEach(function (s) {
    ignoreDict[s.toLowerCase()] = true;
  });

  var helper = new _textlintRuleHelper.RuleHelper(context);
  var Syntax = context.Syntax;
  var RuleError = context.RuleError;
  var fixer = context.fixer;
  var report = context.report;
  var getSource = context.getSource;

  return _defineProperty({}, Syntax.Str, function (node) {
    if (helper.isChildNode(node, [Syntax.BlockQuote])) {
      return;
    }

    return new Promise(function (resolve, reject) {
      var text = getSource(node);
      var dict = _misspellings2.default.dict({ lowerCase: true });
      var re = _misspellings2.default.regexp("ig");

      var matches = void 0;
      while (matches = re.exec(text)) {
        var index = matches.index;
        var misspell = matches[0];
        var dickey = misspell.toLowerCase();
        var range = [index, index + misspell.length];

        // Skip ignored word
        if (ignoreDict[dickey]) continue;

        var csv = dict[dickey];
        if (!csv) continue;

        var corrects = csv.split(",");
        var fix = void 0;
        if (corrects.length === 1) {
          // If there is only one correct word, we can fix this confidently.
          fix = fixer.replaceTextRange(range, mapCases(misspell, corrects[0]));
        }

        var message = "This is a commonly misspelled word. Correct it to " + corrects.join(", ");
        report(node, new RuleError(message, { index: index, fix: fix }));
      }

      resolve();
    });
  });
}

function mapCases(source, dest) {
  var mapped = new Array(dest.length);
  for (var i = 0, l = dest.length; i < l; i++) {
    var sc = source.charCodeAt(i); // becomes NaN when i exceeds source.length
    var dc = dest.charCodeAt(i);

    // If source is upper-case and dest is lower-case
    if (sc >= 0x41 && sc <= 0x5A && dc >= 0x61 && dc <= 0x7A) {
      // Make dest character upper-case
      mapped[i] = dc - 0x20;
    } else {
      mapped[i] = dc;
    }
  }
  return String.fromCharCode.apply(String, mapped);
}

exports.default = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=common-misspellings.js.map