{"version":3,"sources":["../src/textlint-rule-no-empty-section.js"],"names":["createSections","require","module","exports","context","Syntax","RuleError","report","getSource","isHeaderOnly","section","notHeaderNodes","children","filter","child","type","Header","length","findFirstHeader","headerNodes","isEmptySection","Array","isArray","Document","node","sections","forEach","header","index","range"],"mappings":"AAAA;AACA;;;;AACA,IAAMA,iBAAiBC,QAAQ,gBAAR,CAAvB;AACAC,OAAOC,OAAP,GAAiB,UAASC,OAAT,EAAkB;AAAA,QACxBC,MADwB,GACgBD,OADhB,CACxBC,MADwB;AAAA,QAChBC,SADgB,GACgBF,OADhB,CAChBE,SADgB;AAAA,QACLC,MADK,GACgBH,OADhB,CACLG,MADK;AAAA,QACGC,SADH,GACgBJ,OADhB,CACGI,SADH;AAE/B;;;;;;AAKA,QAAMC,eAAe,SAAfA,YAAe,CAACC,OAAD,EAAa;AAC9B,YAAIC,iBAAiBD,QAAQE,QAAR,CAAiBC,MAAjB,CAAwB,iBAAS;AAClD,mBAAOC,MAAMC,IAAN,KAAeV,OAAOW,MAA7B;AACH,SAFoB,CAArB;AAGA,eAAOL,eAAeM,MAAf,KAA0B,CAAjC;AACH,KALD;AAMA;;;;;AAKA,QAAMC,kBAAkB,SAAlBA,eAAkB,CAACR,OAAD,EAAa;AACjC,YAAIS,cAAcT,QAAQE,QAAR,CAAiBC,MAAjB,CAAwB,iBAAS;AAC/C,mBAAOC,MAAMC,IAAN,KAAeV,OAAOW,MAA7B;AACH,SAFiB,CAAlB;AAGA,eAAOG,YAAY,CAAZ,CAAP;AACH,KALD;AAMA;;;;;AAKA,QAAMC,iBAAiB,SAAjBA,cAAiB,CAACV,OAAD,EAAa;AAChC,YAAI,CAACW,MAAMC,OAAN,CAAcZ,QAAQE,QAAtB,CAAL,EAAsC;AAClC,mBAAO,KAAP;AACH;AACD,eAAOH,aAAaC,OAAb,CAAP;AAEH,KAND;AAOA,+BACKL,OAAOkB,QADZ,YACsBC,IADtB,EAC2B;AACnB,YAAMC,WAAWzB,eAAewB,IAAf,CAAjB;AACAC,iBAASZ,MAAT,CAAgBO,cAAhB,EAAgCM,OAAhC,CAAwC,mBAAW;AAC/C,gBAAMC,SAAST,gBAAgBR,OAAhB,CAAf;AACA,gBAAI,CAACiB,MAAL,EAAa;AACT;AACH;AACDpB,mBAAOiB,IAAP,EAAa,IAAIlB,SAAJ,4BAAwCE,UAAUmB,MAAV,CAAxC,QAA+D;AACxEC,uBAAOlB,QAAQmB,KAAR,CAAc,CAAd;AADiE,aAA/D,CAAb;AAGH,SARD;AASH,KAZL;AAcH,CAlDD","file":"textlint-rule-no-empty-section.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst createSections = require(\"select-section\");\nmodule.exports = function(context) {\n    const {Syntax, RuleError, report, getSource} = context;\n    /**\n     * if `section` contain only Header nodes, return true\n     * @param {Object} section\n     * @returns {boolean}\n     */\n    const isHeaderOnly = (section) => {\n        var notHeaderNodes = section.children.filter(child => {\n            return child.type !== Syntax.Header;\n        });\n        return notHeaderNodes.length === 0;\n    };\n    /**\n     * find first Header Node in the `section`\n     * @param {Object} section\n     * @returns {TxtNode}\n     */\n    const findFirstHeader = (section) => {\n        var headerNodes = section.children.filter(child => {\n            return child.type === Syntax.Header;\n        });\n        return headerNodes[0];\n    };\n    /**\n     * if `section` is empty, return true\n     * @param {Object} section\n     * @returns {boolean}\n     */\n    const isEmptySection = (section) => {\n        if (!Array.isArray(section.children)) {\n            return false;\n        }\n        return isHeaderOnly(section);\n\n    };\n    return {\n        [Syntax.Document](node){\n            const sections = createSections(node);\n            sections.filter(isEmptySection).forEach(section => {\n                const header = findFirstHeader(section);\n                if (!header) {\n                    return;\n                }\n                report(node, new RuleError(`Found empty section: \\`${getSource(header)}\\``, {\n                    index: section.range[0]\n                }));\n            });\n        }\n    };\n};"]}