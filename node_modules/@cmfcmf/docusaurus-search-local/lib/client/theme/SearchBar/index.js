import React, { useRef, useEffect, createElement, Fragment } from "react";
import { render } from "react-dom";
import { autocomplete } from "@algolia/autocomplete-js";
import Head from "@docusaurus/Head";
import { interpolate } from "@docusaurus/Interpolate";
import { translate } from "@docusaurus/Translate";
import { useHistory } from "@docusaurus/router";
import useDocusaurusContext from "@docusaurus/useDocusaurusContext";
import { useVersions, useLatestVersion, useActiveVersion, } from "@theme/hooks/useDocs";
import useThemeContext from "@theme/hooks/useThemeContext";
import { mylunr, indexDocSidebarParentCategories, tokenize, } from "./generatedWrapper";
import { HighlightSearchResults } from "./HighlightSearchResults";
const SEARCH_INDEX_AVAILABLE = process.env.NODE_ENV === "production";
function getItemUrl({ document }) {
    const [path, hash] = document.sectionRoute.split("#");
    let url = path;
    if (hash) {
        url += "#" + hash;
    }
    return url;
}
function fetchIndex(baseUrl) {
    if (SEARCH_INDEX_AVAILABLE) {
        return fetch(`${baseUrl}search-index.json`)
            .then((content) => content.json())
            .then((json) => ({
            documents: json.documents,
            index: mylunr.Index.load(json.index),
        }));
    }
    else {
        // The index does not exist in development, therefore load a dummy index here.
        return Promise.resolve({
            documents: [],
            index: mylunr(function () {
                this.ref("id");
                this.field("title");
                this.field("content");
            }),
        });
    }
}
const SearchBar = () => {
    const { siteConfig: { baseUrl }, } = useDocusaurusContext();
    const history = useHistory();
    const versions = useVersions();
    const activeVersion = useActiveVersion();
    const latestVersion = useLatestVersion();
    const versionToSearch = versions.length <= 1 ? undefined : activeVersion ?? latestVersion;
    const index = useRef(null);
    const getIndex = async () => {
        if (index.current !== null && index.current !== "loading") {
            // Do not load the index (again) if its already loaded or in the process of being loaded.
            return index.current;
        }
        index.current = "loading";
        return (index.current = await fetchIndex(baseUrl));
    };
    const placeholder = versionToSearch
        ? interpolate(translate({
            message: "cmfcmf/d-s-l.searchBar.placeholderWithVersion",
            description: "Placeholder shown in the searchbar if it is empty and no documentation version has been detected",
        }), { version: versionToSearch.label })
        : translate({
            message: "cmfcmf/d-s-l.searchBar.placeholderWithoutVersion",
            description: "Placeholder shown in the searchbar if it is empty and a documentation version has been detected (available in the {version} placeholder",
        });
    const autocompleteRef = useRef(null);
    const autocompleteApi = useRef(null);
    useEffect(() => {
        if (!autocompleteRef.current) {
            return;
        }
        autocompleteApi.current = autocomplete({
            container: autocompleteRef.current,
            placeholder,
            // Use React instead of Preact
            renderer: { createElement, Fragment },
            render({ children }, root) {
                render(children, root);
            },
            // Use react-router for navigation
            navigator: {
                navigate({ item, itemUrl }) {
                    history.push(itemUrl, { cmfcmfhighlight: item.terms });
                },
            },
            // always open a modal window
            detachedMediaQuery: "",
            // preselect the first search result
            defaultActiveItemId: 0,
            getSources({ query: input }) {
                return [
                    {
                        sourceId: "search-results",
                        templates: {
                            // footer() {
                            //   return <h1>footer</h1>
                            // },
                            // header() {
                            //   return <h1>header</h1>
                            // },
                            item({ item }) {
                                // if (versionToSearch && document.docVersion !== undefined) {
                                //   result += ` <span class="badge badge--secondary">${escape(
                                //     document.docVersion
                                //   )}</span>`;
                                // }
                                // result += " " + score;
                                const url = getItemUrl(item);
                                return (
                                // We cannot use <Link>, because this stuff is rendered in a completely separate React tree and has no access to the Router and DocusaurusContext.
                                React.createElement("a", { href: url, className: "aa-ItemLink", onClick: (e) => {
                                        e.preventDefault();
                                        history.push(url, { cmfcmfhighlight: item.terms });
                                    } },
                                    React.createElement("div", { className: "aa-ItemContent" },
                                        React.createElement("div", { className: "aa-ItemContentTitle" }, item.document.sectionTitle),
                                        item.document.pageTitle !==
                                            item.document.sectionTitle && (React.createElement("div", { className: "aa-ItemContentDescription" }, item.document.pageTitle))),
                                    React.createElement("div", { className: "aa-ItemActions" },
                                        React.createElement("button", { className: "aa-ItemActionButton aa-DesktopOnly aa-ActiveOnly", type: "button", title: "Select" },
                                            React.createElement("svg", { viewBox: "0 0 24 24", width: "20", height: "20", fill: "currentColor" },
                                                React.createElement("path", { d: "M18.984 6.984h2.016v6h-15.188l3.609 3.609-1.406 1.406-6-6 6-6 1.406 1.406-3.609 3.609h13.172v-4.031z" }))))));
                            },
                            noResults() {
                                return (React.createElement("div", { className: "aa-ItemContent" }, SEARCH_INDEX_AVAILABLE
                                    ? translate({
                                        message: "cmfcmf/d-s-l.searchBar.noResults",
                                        description: "message shown if no results are found",
                                    })
                                    : // No need to translate this message, since its only shown in development.
                                        "The search index is only available when you run docusaurus build!"));
                            },
                        },
                        getItemUrl({ item }) {
                            return getItemUrl(item);
                        },
                        async getItems() {
                            const { documents, index } = await getIndex();
                            const terms = tokenize(input);
                            const results = index
                                .query((query) => {
                                // Boost matches in title by 5
                                query.term(terms, { fields: ["title"], boost: 5 });
                                query.term(terms, {
                                    fields: ["title"],
                                    boost: 5,
                                    wildcard: mylunr.Query.wildcard.TRAILING,
                                });
                                // Boost matches in content by 1
                                query.term(terms, { fields: ["content"], boost: 1 });
                                query.term(terms, {
                                    fields: ["content"],
                                    boost: 1,
                                    wildcard: mylunr.Query.wildcard.TRAILING,
                                });
                                if (indexDocSidebarParentCategories) {
                                    query.term(terms, {
                                        fields: ["sidebarParentCategories"],
                                        boost: 2,
                                    });
                                    query.term(terms, {
                                        fields: ["sidebarParentCategories"],
                                        boost: 2,
                                        wildcard: mylunr.Query.wildcard.TRAILING,
                                    });
                                }
                                if (versionToSearch) {
                                    // We want to search all documents with version = versionToSearch OR version = undefined
                                    // (blog posts and static pages have an undefined version)
                                    //
                                    // Since lunr.js does not allow OR queries, we instead prohibit all versions
                                    // except versionToSearch and undefined.
                                    //
                                    // https://github.com/cmfcmf/docusaurus-search-local/issues/19
                                    versions.forEach((version) => {
                                        if (version.name !== versionToSearch.name) {
                                            query.term(version.name, {
                                                fields: ["version"],
                                                boost: 0,
                                                presence: mylunr.Query.presence.PROHIBITED,
                                            });
                                        }
                                    });
                                }
                            })
                                // We need to remove results with a score of 0 that occur
                                // when the docs are versioned and just the version matches.
                                .filter((result) => result.score > 0)
                                .slice(0, 8)
                                .map((result) => ({
                                document: documents.find((document) => document.id.toString() === result.ref),
                                score: result.score,
                                terms,
                            }));
                            // if (!SEARCH_INDEX_AVAILABLE) {
                            //   results.push({
                            //     score: 0.5,
                            //     document: {
                            //       id: 1,
                            //       pageTitle: "BLOG POST TITLE",
                            //       sectionTitle: "BLOG POST TITLE",
                            //       sectionRoute: "/blog/d-s-l-test",
                            //     },
                            //     terms: ["a", "b"],
                            //   });
                            // }
                            return results;
                        },
                    },
                ];
            },
        });
        return () => autocompleteApi.current?.destroy();
    }, []);
    useEffect(() => {
        if (autocompleteApi.current) {
            autocompleteApi.current.update({
                placeholder,
            });
        }
    }, [placeholder]);
    const isDarkTheme = useThemeContext().isDarkTheme;
    return (React.createElement(React.Fragment, null,
        React.createElement(Head, null,
            React.createElement("body", { "data-theme": isDarkTheme ? "dark" : "light" })),
        React.createElement(HighlightSearchResults, null),
        React.createElement("div", { className: "dsla-search-wrapper" },
            React.createElement("div", { className: "dsla-search-field", ref: autocompleteRef }))));
};
export default SearchBar;
