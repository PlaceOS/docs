"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = tslib_1.__importDefault(require("util"));
const utils_1 = require("@docusaurus/utils");
const lunr_1 = tslib_1.__importDefault(require("lunr"));
const readFileAsync = util_1.default.promisify(fs_1.default.readFile);
const writeFileAsync = util_1.default.promisify(fs_1.default.writeFile);
const parse_1 = require("./parse");
const logger_1 = tslib_1.__importDefault(require("./logger"));
// FIXME: Duplicated in src/theme/SearchBar/util.js
function urlMatchesPrefix(url, prefix) {
    if (prefix.endsWith("/")) {
        throw new Error(`prefix must not end with a /. This is a bug.`);
    }
    return prefix === "" || url === prefix || url.startsWith(`${prefix}/`);
}
function cmfcmfDocusaurusSearchLocal(context, options) {
    let blogBasePath = options.blogRouteBasePath !== undefined
        ? options.blogRouteBasePath
        : "/blog";
    let docsBasePath = options.docsRouteBasePath !== undefined
        ? options.docsRouteBasePath
        : "/docs";
    const indexPages = options.indexPages !== undefined ? options.indexPages : false;
    const indexBlog = options.indexBlog !== undefined ? options.indexBlog : true;
    const indexDocs = options.indexDocs !== undefined ? options.indexDocs : true;
    let language = options.language !== undefined ? options.language : "en";
    const indexDocSidebarParentCategories = options.indexDocSidebarParentCategories !== undefined
        ? options.indexDocSidebarParentCategories
        : 0;
    if (typeof indexDocSidebarParentCategories !== "number") {
        throw new Error("indexDocSidebarParentCategories must be a number, set to 0 to disable.");
    }
    const lunrSettings = options.lunr !== undefined ? options.lunr : {};
    const lunrTokenizerSeparator = lunrSettings.tokenizerSeparator;
    if (lunrTokenizerSeparator !== undefined) {
        // @ts-expect-error
        lunr_1.default.tokenizer.separator = lunrTokenizerSeparator;
    }
    const style = options.style;
    if (Array.isArray(language) && language.length === 1) {
        language = language[0];
    }
    if (!blogBasePath.startsWith("/")) {
        throw new Error(`blogBasePath must start with /, received: '${blogBasePath}'.`);
    }
    if (!docsBasePath.startsWith("/")) {
        throw new Error(`docsBasePath must start with /, received: '${docsBasePath}'.`);
    }
    blogBasePath = blogBasePath.substr(1);
    docsBasePath = docsBasePath.substr(1);
    const docsDir = path_1.default.resolve(context.siteDir, "docs");
    let docVersions = [];
    let useDocVersioning = false;
    if (!fs_1.default.existsSync(docsDir)) {
        logger_1.default.info(`Skipping search index generation for documentation because directory ${docsDir} does not exist.`);
    }
    else {
        const versionsPath = path_1.default.join(docsDir, "..", "versions.json");
        if (fs_1.default.existsSync(versionsPath)) {
            useDocVersioning = true;
            docVersions = [
                ...JSON.parse(fs_1.default.readFileSync(versionsPath, "utf-8")),
                "next",
            ];
            logger_1.default.info(`The following documentation versions were detected: ${docVersions.join(", ")}`);
        }
        else {
            logger_1.default.info(`The documentation is not versioned (${versionsPath} does not exist).`);
        }
    }
    let generated = "// THIS FILE IS AUTOGENERATED\n" + "// DO NOT EDIT THIS FILE!\n\n";
    if (style !== "none") {
        generated += 'require("@algolia/autocomplete-theme-classic");\n';
        generated += 'import "./index.css";\n';
    }
    generated += 'import * as lunr from "lunr";\n';
    function handleLangCode(code) {
        let generated = "";
        if (code === "jp") {
            throw new Error(`Language "jp" is deprecated, please use "ja".`);
        }
        if (code === "ja") {
            require("lunr-languages/tinyseg")(lunr_1.default);
            generated += `require("lunr-languages/tinyseg")(lunr);\n`;
        }
        else if (code === "th") {
            // @ts-expect-error see
            // https://github.com/MihaiValentin/lunr-languages/blob/a62fec97fb1a62bb4581c9b69a5ddedf62f8f62f/test/VersionsAndLanguagesTest.js#L110-L112
            lunr_1.default.wordcut = require("lunr-languages/wordcut");
            generated += `lunr.wordcut = require("lunr-languages/wordcut");\n`;
        }
        require(`lunr-languages/lunr.${code}`)(lunr_1.default);
        generated += `require("lunr-languages/lunr.${code}")(lunr);\n`;
        return generated;
    }
    if (language !== "en") {
        require("lunr-languages/lunr.stemmer.support")(lunr_1.default);
        generated += 'require("lunr-languages/lunr.stemmer.support")(lunr);\n';
        if (Array.isArray(language)) {
            language
                .filter((code) => code !== "en")
                .forEach((code) => {
                generated += handleLangCode(code);
            });
            require("lunr-languages/lunr.multi")(lunr_1.default);
            generated += `require("lunr-languages/lunr.multi")(lunr);\n`;
        }
        else {
            generated += handleLangCode(language);
        }
    }
    if (language === "ja" || language === "th") {
        if (lunrTokenizerSeparator) {
            throw new Error("The lunr.tokenizerSeparator option is not supported for 'ja' and 'th' languages.");
        }
        generated += `\
export const tokenize = (input) => lunr[${JSON.stringify(language)}].tokenizer(input)
  .map(token => token${language === "th" ? "" : ".str"});\n`;
    }
    else {
        if (lunrTokenizerSeparator) {
            generated += `\
lunr.tokenizer.separator = ${lunrTokenizerSeparator.toString()};\n`;
        }
        generated += `\
export const tokenize = (input) => lunr.tokenizer(input)
  .map(token => token.str);\n`;
    }
    generated += `export const mylunr = lunr;\n`;
    generated += `export const docsBasePath = ${JSON.stringify(docsBasePath)};\n`;
    generated += `export const blogBasePath = ${JSON.stringify(blogBasePath)};\n`;
    generated += `export const indexDocSidebarParentCategories = ${JSON.stringify(indexDocSidebarParentCategories)};\n`;
    ["src", "lib"].forEach((folder) => {
        const generatedPath = path_1.default.join(__dirname, "..", "..", folder, "client", "theme", "SearchBar", "generated.js");
        fs_1.default.writeFileSync(generatedPath, generated);
    });
    return {
        name: "@cmfcmf/docusaurus-search-local",
        getThemePath() {
            return path_1.default.resolve(__dirname, "..", "..", "lib", "client", "theme");
        },
        getTypeScriptThemePath() {
            return path_1.default.resolve(__dirname, "..", "..", "src", "client", "theme");
        },
        getDefaultCodeTranslationMessages: () => utils_1.readDefaultCodeTranslationMessages({
            dirPath: path_1.default.resolve(__dirname, "..", "..", "codeTranslations"),
            locale: context.i18n.currentLocale,
        }),
        async postBuild({ routesPaths = [], outDir, baseUrl }) {
            logger_1.default.info("Gathering documents");
            const data = routesPaths
                .flatMap((url) => {
                const route = url.substr(baseUrl.length);
                if (!url.startsWith(baseUrl)) {
                    throw new Error(`The route must start with the baseUrl ${baseUrl}, but was ${route}. This is a bug, please report it.`);
                }
                if (route === "404.html") {
                    // Do not index error page.
                    return [];
                }
                if (indexBlog && urlMatchesPrefix(route, blogBasePath)) {
                    if (route === blogBasePath ||
                        urlMatchesPrefix(route, `${blogBasePath}/tags`)) {
                        // Do not index list of blog posts and tags filter pages
                        return [];
                    }
                    return { route, url, type: "blog" };
                }
                if (indexDocs && urlMatchesPrefix(route, docsBasePath)) {
                    return { route, url, type: "docs" };
                }
                if (indexPages) {
                    return { route, url, type: "page" };
                }
                return [];
            })
                .map(({ route, url, type }) => {
                const file = path_1.default.join(outDir, route, "index.html");
                return {
                    file,
                    url,
                    type,
                };
            });
            logger_1.default.info("Parsing documents");
            // Give every index entry a unique id so that the index does not need to store long URLs.
            let nextDocId = 1;
            const documents = (await Promise.all(data.map(async ({ file, url, type }) => {
                logger_1.default.debug(`Parsing ${type} file ${file}`, { url });
                const html = await readFileAsync(file, { encoding: "utf8" });
                const { pageTitle, sections, docSidebarParentCategories, } = parse_1.html2text(html, type, url);
                const docVersion = parse_1.getDocVersion(html);
                return sections.map((section) => ({
                    id: nextDocId++,
                    pageTitle,
                    pageRoute: url,
                    sectionRoute: url + section.hash,
                    sectionTitle: section.title,
                    sectionContent: section.content,
                    docVersion,
                    docSidebarParentCategories,
                }));
            }))).flat();
            logger_1.default.info("Building index");
            const index = lunr_1.default(function () {
                if (language !== "en") {
                    if (Array.isArray(language)) {
                        // @ts-expect-error
                        this.use(lunr_1.default.multiLanguage(...language));
                    }
                    else {
                        // @ts-expect-error
                        this.use(lunr_1.default[language]);
                    }
                }
                this.ref("id");
                this.field("title");
                this.field("content");
                if (useDocVersioning) {
                    this.field("version");
                }
                if (indexDocSidebarParentCategories > 0) {
                    this.field("sidebarParentCategories");
                }
                const that = this;
                documents.forEach(function ({ id, sectionTitle, sectionContent, docVersion, docSidebarParentCategories, }) {
                    let sidebarParentCategories;
                    if (indexDocSidebarParentCategories > 0 &&
                        docSidebarParentCategories) {
                        sidebarParentCategories = docSidebarParentCategories
                            .reverse()
                            .slice(0, indexDocSidebarParentCategories)
                            .join(" ");
                    }
                    that.add({
                        id: id.toString(),
                        title: sectionTitle,
                        content: sectionContent,
                        version: docVersion,
                        sidebarParentCategories: sidebarParentCategories,
                    });
                });
            });
            logger_1.default.info("Writing index to disk");
            await writeFileAsync(path_1.default.join(outDir, "search-index.json"), JSON.stringify({
                documents: documents.map(({ id, pageTitle, sectionTitle, sectionRoute, docVersion }) => ({
                    id,
                    pageTitle,
                    sectionTitle,
                    sectionRoute,
                    // Only include docVersion metadata if versioning is used
                    docVersion: useDocVersioning ? docVersion : undefined,
                })),
                index,
            }), { encoding: "utf8" });
            logger_1.default.info("Index written to disk, success!");
        },
    };
}
exports.default = cmfcmfDocusaurusSearchLocal;
