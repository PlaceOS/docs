{"version":3,"sources":["../src/select-section.js"],"names":[],"mappings":"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","file":"select-section.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst traverse = require(\"txt-ast-traverse\").traverse;\nconst Map = require(\"map-like\");\n\nclass Section {\n    constructor(level) {\n        this.level = level;\n        this.nodes = [];\n    }\n\n    isSameLevel(level) {\n        return level === this.level;\n    }\n\n    add(node) {\n        this.nodes.push(node);\n    }\n\n    toArray() {\n        return this.nodes.slice();\n    }\n\n    toSectionNode() {\n        const nodes = this.toArray();\n        const firstNode = nodes[0];\n        const lastNode = nodes[nodes.length - 1];\n        if (!firstNode || !lastNode) {\n            return {\n                type: \"Section\",\n                children: []\n            }\n        }\n        return {\n            type: \"Section\",\n            range: firstNode.position\n                   ? [firstNode.position.start.offset, lastNode.position.end.offset]\n                   : [firstNode.range[0], lastNode.range[1]],\n            loc: {\n                start: firstNode.position\n                       ? firstNode.position.start.offset\n                       : firstNode.loc.start,\n                end: lastNode.position\n                     ? lastNode.position.end.offset\n                     : lastNode.loc.end\n            },\n            raw: nodes.map(node => node.raw).join(\"\"),\n            children: nodes\n        };\n    }\n}\n\nclass Sections {\n    constructor() {\n        this.sectionMap = new Map();\n    }\n\n    getAllSections() {\n        return this.sectionMap.values();\n    }\n\n    getSection(depth) {\n        return this.sectionMap.get(depth);\n    }\n\n    /**\n     * @param {number} depth\n     * @returns {boolean}\n     */\n    hasSection(depth) {\n        return this.sectionMap.has(depth)\n    }\n\n    /**\n     * @param {Section} section\n     */\n    addSection(section) {\n        this.sectionMap.set(section.level, section);\n    }\n\n    /**\n     * @param {Object} node\n     */\n    addNodeToAllSections(node) {\n        this.sectionMap.forEach(section => {\n            section.add(node);\n        });\n    }\n\n    /**\n     * @param {number} depth\n     * @returns {*}\n     */\n    popSection(depth) {\n        const section = this.sectionMap.get(depth);\n        this.sectionMap.delete(depth);\n        return section;\n    }\n}\n\n/**\n * create `sections` from `txtAST`\n * @param {Object} txtAST\n * @returns {Array[]} sections - the section is array of the section nodes\n */\nmodule.exports = function(txtAST) {\n    let traversingLevel = 0;\n    let previousHeaderLevel = NaN;\n    const sections = new Sections();\n    const rootSection = new Section(0);\n    sections.addSection(rootSection);\n    const resultSections = [rootSection];\n    // support txt-ast and mdast\n    const headerType = /(Header|heading)/i;\n    // remark and txtast\n    const rootType = /(Document|Root)/i;\n\n    traverse(txtAST, {\n        enter(node) {\n            if (headerType.test(node.type)) {\n                if (!sections.hasSection(node.depth)) {\n                    const newSection = new Section(node.depth);\n                    sections.addSection(newSection);\n                } else {\n                    const prevSection = sections.popSection(node.depth);\n                    resultSections.push(prevSection);\n                    const newSection = new Section(node.depth);\n                    sections.addSection(newSection);\n                }\n                previousHeaderLevel = traversingLevel;\n            }\n            if (traversingLevel === previousHeaderLevel) {\n                sections.addNodeToAllSections(node);\n            }\n            traversingLevel++;\n        },\n        leave(node) {\n            traversingLevel--;\n            if (rootType.test(node.type)) {\n                sections.getAllSections().forEach(section => {\n                    if (resultSections.indexOf(section) === -1) {\n                        resultSections.push(section);\n                    }\n                });\n            }\n        }\n    });\n    return resultSections.map(section => section.toSectionNode());\n};\n"]}