// LICENSE : MIT
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var traverse = require("txt-ast-traverse").traverse;
var Map = require("map-like");

var Section = function () {
    function Section(level) {
        _classCallCheck(this, Section);

        this.level = level;
        this.nodes = [];
    }

    _createClass(Section, [{
        key: "isSameLevel",
        value: function isSameLevel(level) {
            return level === this.level;
        }
    }, {
        key: "add",
        value: function add(node) {
            this.nodes.push(node);
        }
    }, {
        key: "toArray",
        value: function toArray() {
            return this.nodes.slice();
        }
    }, {
        key: "toSectionNode",
        value: function toSectionNode() {
            var nodes = this.toArray();
            var firstNode = nodes[0];
            var lastNode = nodes[nodes.length - 1];
            if (!firstNode || !lastNode) {
                return {
                    type: "Section",
                    children: []
                };
            }
            return {
                type: "Section",
                range: firstNode.position ? [firstNode.position.start.offset, lastNode.position.end.offset] : [firstNode.range[0], lastNode.range[1]],
                loc: {
                    start: firstNode.position ? firstNode.position.start.offset : firstNode.loc.start,
                    end: lastNode.position ? lastNode.position.end.offset : lastNode.loc.end
                },
                raw: nodes.map(function (node) {
                    return node.raw;
                }).join(""),
                children: nodes
            };
        }
    }]);

    return Section;
}();

var Sections = function () {
    function Sections() {
        _classCallCheck(this, Sections);

        this.sectionMap = new Map();
    }

    _createClass(Sections, [{
        key: "getAllSections",
        value: function getAllSections() {
            return this.sectionMap.values();
        }
    }, {
        key: "getSection",
        value: function getSection(depth) {
            return this.sectionMap.get(depth);
        }

        /**
         * @param {number} depth
         * @returns {boolean}
         */

    }, {
        key: "hasSection",
        value: function hasSection(depth) {
            return this.sectionMap.has(depth);
        }

        /**
         * @param {Section} section
         */

    }, {
        key: "addSection",
        value: function addSection(section) {
            this.sectionMap.set(section.level, section);
        }

        /**
         * @param {Object} node
         */

    }, {
        key: "addNodeToAllSections",
        value: function addNodeToAllSections(node) {
            this.sectionMap.forEach(function (section) {
                section.add(node);
            });
        }

        /**
         * @param {number} depth
         * @returns {*}
         */

    }, {
        key: "popSection",
        value: function popSection(depth) {
            var section = this.sectionMap.get(depth);
            this.sectionMap.delete(depth);
            return section;
        }
    }]);

    return Sections;
}();

/**
 * create `sections` from `txtAST`
 * @param {Object} txtAST
 * @returns {Array[]} sections - the section is array of the section nodes
 */


module.exports = function (txtAST) {
    var traversingLevel = 0;
    var previousHeaderLevel = NaN;
    var sections = new Sections();
    var rootSection = new Section(0);
    sections.addSection(rootSection);
    var resultSections = [rootSection];
    // support txt-ast and mdast
    var headerType = /(Header|heading)/i;
    // remark and txtast
    var rootType = /(Document|Root)/i;

    traverse(txtAST, {
        enter: function enter(node) {
            if (headerType.test(node.type)) {
                if (!sections.hasSection(node.depth)) {
                    var newSection = new Section(node.depth);
                    sections.addSection(newSection);
                } else {
                    var prevSection = sections.popSection(node.depth);
                    resultSections.push(prevSection);
                    var _newSection = new Section(node.depth);
                    sections.addSection(_newSection);
                }
                previousHeaderLevel = traversingLevel;
            }
            if (traversingLevel === previousHeaderLevel) {
                sections.addNodeToAllSections(node);
            }
            traversingLevel++;
        },
        leave: function leave(node) {
            traversingLevel--;
            if (rootType.test(node.type)) {
                sections.getAllSections().forEach(function (section) {
                    if (resultSections.indexOf(section) === -1) {
                        resultSections.push(section);
                    }
                });
            }
        }
    });
    return resultSections.map(function (section) {
        return section.toSectionNode();
    });
};
//# sourceMappingURL=select-section.js.map