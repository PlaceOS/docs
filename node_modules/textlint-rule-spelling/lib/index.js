/*
 * This file is part of textlint-rule-spelling
 *
 * textlint-rule-spelling is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * textlint-rule-spelling is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with textlint-rule-spelling.  If not, see <http://www.gnu.org/licenses/>.
 */
"use strict";

var fs = require("fs");

var path = require("path");

var nspell = require("nspell");

var {
  matchPatterns
} = require("@textlint/regexp-string-matcher");

var constructNSpell = function constructNSpell(language) {
  var base = require.resolve("dictionary-".concat(language));

  var dictionary = fs.readFileSync(path.join(base, "..", "index.dic"), "utf-8");
  var affix = fs.readFileSync(path.join(base, "..", "index.aff"), "utf-8");
  return nspell(affix, dictionary);
};

var getRuleErrorBuilder = (nSpell, suggestCorrections, RuleError, fixer) => {
  if (suggestCorrections) {
    return (word, originalRange) => {
      var suggestions = nSpell.suggest(word);
      var fix = suggestions.length === 1 ? fixer.replaceTextRange(originalRange, suggestions[0]) : undefined;
      var message = "".concat(word, " -> ").concat(suggestions.join(", "));
      return new RuleError(message, {
        index: originalRange[0],
        fix: fix
      });
    };
  } else {
    return (word, originalRange) => {
      return new RuleError(word, {
        index: originalRange[0]
      });
    };
  }
};

var doesExclusionOverlapWord = (_ref, _ref2) => {
  var [exclusionRangeStart, exclusionRangeEnd] = _ref;
  var [wordRangeStart, wordRangeEnd] = _ref2;
  var startsBeforeEndOfExclusion = wordRangeStart <= exclusionRangeEnd;
  var endsAfterStartOfExclusion = wordRangeEnd >= exclusionRangeStart;
  return startsBeforeEndOfExclusion && endsAfterStartOfExclusion;
};

var getNoExclusionsOverlapWord = (exclusions, indexOffset) => {
  if (exclusions && exclusions.length > 0) {
    return originalRange => {
      return !exclusions.some((_ref3) => {
        var {
          startIndex,
          endIndex
        } = _ref3;
        return doesExclusionOverlapWord([startIndex + indexOffset, endIndex + indexOffset], originalRange);
      });
    };
  }

  return originalRange => true;
};

var reporter = function reporter(_ref4, _ref5) {
  var {
    Syntax,
    RuleError,
    fixer,
    report
  } = _ref4;
  var {
    language = "en",
    skipPatterns = [],
    wordDefinitionRegexp: optionWordDefinitionRegexp = /\b[\w']+\b/g,
    suggestCorrections = true
  } = _ref5;
  var nSpell = constructNSpell(language);
  var ruleErrorBuilder = getRuleErrorBuilder(nSpell, suggestCorrections, RuleError, fixer);

  var handleText = (node, text, indexOffset) => {
    if (!text) return;
    var wordDefinitionRegexp = new RegExp(optionWordDefinitionRegexp, "g");
    var noExclusionsOverlapWord;

    while (true) {
      var matches = wordDefinitionRegexp.exec(text);

      if (matches === null) {
        break;
      }

      if (matches.index === wordDefinitionRegexp.lastIndex) {
        wordDefinitionRegexp.lastIndex++;
      }

      var originalIndex = indexOffset + matches.index;
      var word = matches[0];
      var originalWordRange = [originalIndex, originalIndex + word.length];

      if (!nSpell.correct(word)) {
        noExclusionsOverlapWord = noExclusionsOverlapWord || getNoExclusionsOverlapWord(matchPatterns(text, skipPatterns), indexOffset);

        if (noExclusionsOverlapWord(originalWordRange)) {
          report(node, ruleErrorBuilder(word, originalWordRange));
        }
      }
    }
  };

  return {
    [Syntax.Str](node) {
      var {
        value
      } = node;
      handleText(node, value, 0);
    },

    [Syntax.Link](node) {
      var {
        title,
        raw
      } = node;
      handleText(node, title, raw.indexOf(title));
    },

    [Syntax.Image](node) {
      var {
        alt,
        title,
        raw
      } = node;

      if (alt) {
        var indexOfAlt = raw.indexOf(alt);
        handleText(node, alt, indexOfAlt);
      }

      if (title) {
        var indexOfTitle = raw.indexOf(title);
        handleText(node, title, indexOfTitle);
      }
    }

  };
};

module.exports = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=index.js.map