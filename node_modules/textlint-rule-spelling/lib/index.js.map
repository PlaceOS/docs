{"version":3,"sources":["../src/index.js"],"names":["fs","require","path","nspell","matchPatterns","constructNSpell","language","base","resolve","dictionary","readFileSync","join","affix","getRuleErrorBuilder","nSpell","suggestCorrections","RuleError","fixer","word","originalRange","suggestions","suggest","fix","length","replaceTextRange","undefined","message","index","doesExclusionOverlapWord","exclusionRangeStart","exclusionRangeEnd","wordRangeStart","wordRangeEnd","startsBeforeEndOfExclusion","endsAfterStartOfExclusion","getNoExclusionsOverlapWord","exclusions","indexOffset","some","startIndex","endIndex","reporter","Syntax","report","skipPatterns","wordDefinitionRegexp","optionWordDefinitionRegexp","ruleErrorBuilder","handleText","node","text","RegExp","noExclusionsOverlapWord","matches","exec","lastIndex","originalIndex","originalWordRange","correct","Str","value","Link","title","raw","indexOf","Image","alt","indexOfAlt","indexOfTitle","module","exports","linter"],"mappings":"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","sourcesContent":["/*\n * This file is part of textlint-rule-spelling\n *\n * textlint-rule-spelling is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * textlint-rule-spelling is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with textlint-rule-spelling.  If not, see <http://www.gnu.org/licenses/>.\n */\n\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst nspell = require(\"nspell\");\nconst { matchPatterns } = require(\"@textlint/regexp-string-matcher\");\n\nconst constructNSpell = function (language) {\n  const base = require.resolve(`dictionary-${language}`);\n  const dictionary = fs.readFileSync(\n    path.join(base, \"..\", \"index.dic\"),\n    \"utf-8\"\n  );\n  const affix = fs.readFileSync(path.join(base, \"..\", \"index.aff\"), \"utf-8\");\n  return nspell(affix, dictionary);\n};\n\nconst getRuleErrorBuilder = (nSpell, suggestCorrections, RuleError, fixer) => {\n  if (suggestCorrections) {\n    return (word, originalRange) => {\n      const suggestions = nSpell.suggest(word);\n      const fix =\n        suggestions.length === 1\n          ? fixer.replaceTextRange(originalRange, suggestions[0])\n          : undefined;\n      const message = `${word} -> ${suggestions.join(\", \")}`;\n      return new RuleError(message, {\n        index: originalRange[0],\n        fix: fix,\n      });\n    };\n  } else {\n    return (word, originalRange) => {\n      return new RuleError(word, {\n        index: originalRange[0],\n      });\n    };\n  }\n};\n\nconst doesExclusionOverlapWord = (\n  [exclusionRangeStart, exclusionRangeEnd],\n  [wordRangeStart, wordRangeEnd]\n) => {\n  const startsBeforeEndOfExclusion = wordRangeStart <= exclusionRangeEnd;\n  const endsAfterStartOfExclusion = wordRangeEnd >= exclusionRangeStart;\n  return startsBeforeEndOfExclusion && endsAfterStartOfExclusion;\n};\n\nconst getNoExclusionsOverlapWord = (exclusions, indexOffset) => {\n  if (exclusions && exclusions.length > 0) {\n    return (originalRange) => {\n      return !exclusions.some(({ startIndex, endIndex }) =>\n        doesExclusionOverlapWord(\n          [startIndex + indexOffset, endIndex + indexOffset],\n          originalRange\n        )\n      );\n    };\n  }\n  return (originalRange) => true;\n};\n\nconst reporter = function (\n  { Syntax, RuleError, fixer, report },\n  {\n    language = \"en\",\n    skipPatterns = [],\n    wordDefinitionRegexp: optionWordDefinitionRegexp = /\\b[\\w']+\\b/g,\n    suggestCorrections = true,\n  }\n) {\n  const nSpell = constructNSpell(language);\n\n  const ruleErrorBuilder = getRuleErrorBuilder(\n    nSpell,\n    suggestCorrections,\n    RuleError,\n    fixer\n  );\n\n  const handleText = (node, text, indexOffset) => {\n    if (!text) return;\n    const wordDefinitionRegexp = new RegExp(optionWordDefinitionRegexp, \"g\");\n\n    let noExclusionsOverlapWord;\n\n    while (true) {\n      const matches = wordDefinitionRegexp.exec(text);\n      if (matches === null) {\n        break;\n      }\n      if (matches.index === wordDefinitionRegexp.lastIndex) {\n        wordDefinitionRegexp.lastIndex++;\n      }\n      const originalIndex = indexOffset + matches.index;\n      const word = matches[0];\n\n      const originalWordRange = [originalIndex, originalIndex + word.length];\n\n      if (!nSpell.correct(word)) {\n        noExclusionsOverlapWord =\n          noExclusionsOverlapWord ||\n          getNoExclusionsOverlapWord(\n            matchPatterns(text, skipPatterns),\n            indexOffset\n          );\n        if (noExclusionsOverlapWord(originalWordRange)) {\n          report(node, ruleErrorBuilder(word, originalWordRange));\n        }\n      }\n    }\n  };\n\n  return {\n    [Syntax.Str](node) {\n      const { value } = node;\n      handleText(node, value, 0);\n    },\n    [Syntax.Link](node) {\n      const { title, raw } = node;\n      handleText(node, title, raw.indexOf(title));\n    },\n    [Syntax.Image](node) {\n      const { alt, title, raw } = node;\n\n      if (alt) {\n        const indexOfAlt = raw.indexOf(alt);\n        handleText(node, alt, indexOfAlt);\n      }\n      if (title) {\n        const indexOfTitle = raw.indexOf(title);\n        handleText(node, title, indexOfTitle);\n      }\n    },\n  };\n};\n\nmodule.exports = {\n  linter: reporter,\n  fixer: reporter,\n};\n"],"file":"index.js"}