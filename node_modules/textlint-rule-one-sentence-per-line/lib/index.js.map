{"version":3,"sources":["../src/index.js"],"names":["splitter","require","getParents","node","result","parent","push","isNodeWrapped","types","parents","parentsTypes","map","type","some","parentType","reporter","context","Syntax","RuleError","fixer","report","getSource","Paragraph","Header","text","split","filter","x","length","allSentencesHaveNewlines","element","index","nextElement","raw","includes","fixed","join","fix","replaceText","linter"],"mappings":"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","sourcesContent":["const splitter = require(\"sentence-splitter\")\n\n/**\n * Get parents of node.\n * The parent nodes are returned in order from the closest parent to the outer ones.\n * @param node\n * @returns {Array}\n */\nfunction getParents(node) {\n  const result = []\n  // child node has `parent` property.\n  let parent = node.parent\n  while (parent != null) {\n    result.push(parent)\n    parent = parent.parent\n  }\n  return result\n}\n\n/**\n * Return true if `node` is wrapped any one of `types`.\n * @param {TxtNode} node is target node\n * @param {string[]} types are wrapped target node\n * @returns {boolean|*}\n */\nfunction isNodeWrapped(node, types) {\n  const parents = getParents(node)\n  const parentsTypes = parents.map(function(parent) {\n    return parent.type\n  })\n  return types.some(function(type) {\n    return parentsTypes.some(function(parentType) {\n      return parentType === type\n    })\n  })\n}\n\nconst reporter = context => {\n  const { Syntax, RuleError, fixer, report, getSource } = context\n  return {\n    [Syntax.Paragraph](node) {\n      // Titles aren't sembr since breaks do affect them\n      if (isNodeWrapped(node, [Syntax.Header])) {\n        return\n      }\n      const text = getSource(node)\n      const split = splitter.split(text)\n\n      // if there is only one sentence in the line, return early it's following sembr\n      if (split.filter(x => x.type == \"Sentence\").length == 1) {\n        return\n      }\n      // Sometimes, we might get a case where two lines are separated by whitespaces,\n      // but are passed together. For example:\n      //\n      // Hello World!\n      // My Name is Benjamin.\n      //\n      // Would yield [\"Hello World!\", \"\\n\", \"My name is Benjamin.\"] when split by sentence-splitter\n      // This has two sentences in it but is proper sembr\n      //\n      // Similarly, we need to check even in the case where the new line is indented.\n      // sentence-splitter treats this as a separate whitespace from the \\n, so we just\n      // need to see that every sentence has a newline after it some time before the\n      // next sentence starts.\n\n      // a placeholder variable\n      let allSentencesHaveNewlines = true\n\n      for (let node = 0; node < split.length; node++) {\n        const element = split[node]\n\n        // we only care about sentences\n        if (element.type != \"Sentence\") {\n          continue\n        }\n\n        // for each sentence, we're going to check util we find another sentence\n        for (let index = 1; index < split.length - node; index++) {\n          const nextElement = split[node + index]\n          // check to see if the whitespace has a newline\n          if (\n            nextElement.type == \"WhiteSpace\" &&\n            nextElement.raw.includes(\"\\n\")\n          ) {\n            break\n          }\n          // if not, and the next element is a sentence, we found a sentence on the same\n          // line, so we shouldn't return early\n          if (nextElement.type == \"Sentence\") {\n            allSentencesHaveNewlines = false\n          }\n        }\n      }\n      // return early if we haven't found sentences on a new line.\n      if (allSentencesHaveNewlines) {\n        return\n      }\n\n      // insert the newlines\n      const fixed = split\n        .filter(x => x.type == \"Sentence\")\n        .map(x => x.raw)\n        .join(\"\\n\")\n\n      // when we found more than one sentence per line, propose a fix\n      report(\n        node,\n        new RuleError(\"More than one sentence per line\", {\n          fix: fixer.replaceText(node, fixed)\n        })\n      )\n    }\n  }\n}\n\nexport default {\n  linter: reporter,\n  fixer: reporter\n}\n"],"file":"index.js"}