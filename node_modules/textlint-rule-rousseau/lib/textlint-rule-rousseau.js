// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var StringSource = require("textlint-util-to-string");

var rousseau = require("rousseau");

var map = require("unist-util-map");

var defaultOptions = {
  // "suggestion", "warning", "error"
  showLevels: ["suggestion", "warning", "error"],
  // ignore check type of https://github.com/GitbookIO/rousseau#checks
  ignoreTypes: [],
  // ignore textlint's node type
  ignoreInlineNodeTypes: ["Code"]
};

var mapNode = function mapNode(ast, mapFn) {
  return function preorder(node, index, parent) {
    var newNode = Object.assign({}, mapFn(node, index, parent));

    if (node.children) {
      newNode.children = node.children.map(function (child, index) {
        return preorder(child, index, node);
      });
    }

    return newNode;
  }(ast, null, null);
};

module.exports = function textlintRousseau(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
  var helper = new _textlintRuleHelper.RuleHelper(context);
  var ignoreNodeManager = new _textlintRuleHelper.IgnoreNodeManager();
  var Syntax = context.Syntax,
      RuleError = context.RuleError,
      report = context.report,
      getSource = context.getSource;
  var showLevels = options.showLevels || defaultOptions.showLevels;
  var ignoreTypes = options.ignoreTypes || defaultOptions.ignoreTypes;
  var ignoreInlineNodeTypes = options.ignoreInlineNodeTypes || [Syntax.Code];

  var isShowType = function isShowType(type) {
    return ignoreTypes.indexOf(type) === -1;
  };

  var isShowLevel = function isShowLevel(level) {
    return showLevels.indexOf(level) !== -1;
  };
  /*
   {
       // Type of check that output this suggestion
       type: "so",
        // Level of importance
       // "suggestion", "warning", "error"
       level: "warning",
        // Index in the text
       index: 10,
        // Size of the section in the text
       offset: 2,
        // Message to describe the suggestion
       message: "omit 'So' from the beginning of sentences",
        // Replacements suggestion
       replacements: [
           {
              value: ""
           }
       ]
   }
   */


  var createSuggest = function createSuggest(replacements) {
    if (replacements.length === 0) {
      return "";
    }

    return "\nSuggestions:\n" + replacements.map(function (_ref) {
      var value = _ref.value;
      return "=> " + value;
    }).join("\n");
  };

  var reportError = function reportError(node, source, result) {
    var level = result.level;
    var type = result.type; // if not contains showing options, ignore this result

    if (!isShowLevel(level)) {
      return;
    }

    if (!isShowType(type)) {
      return;
    }

    var index = source.originalIndexFromIndex(result.index); // if already ignored, should not report

    if (ignoreNodeManager.isIgnoredIndex(index)) {
      return;
    }

    var suggestions = createSuggest(result.replacements);
    var ruleError = new RuleError("".concat(level, "(").concat(type, ") ").concat(result.message).concat(suggestions), {
      index: index
    });
    report(node, ruleError);
  };

  return _defineProperty({}, Syntax.Paragraph, function (node) {
    // ignore if wrapped node types
    if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
      return;
    } // ignore if contain child node types


    ignoreNodeManager.ignoreChildrenByTypes(node, ignoreInlineNodeTypes); // check
    // replace code with dummy code
    // if you want to filter(remove) code, use https://github.com/eush77/unist-util-filter

    var filteredNode = map(node, function (node) {
      if (node.type === Syntax.Code) {
        // only change `value` to dummy
        return Object.assign({}, node, {
          value: new Array(node.value.length + 1).join("x")
        });
      }

      return node;
    });

    if (!filteredNode) {
      return;
    }

    var source = new StringSource(filteredNode);
    var text = source.toString();

    var reportSourceError = function reportSourceError(results) {
      reportError(node, source, results);
    };

    rousseau(text, function (err, results) {
      if (err) {
        throw err;
      }

      results.forEach(reportSourceError);
    });
  });
};
//# sourceMappingURL=textlint-rule-rousseau.js.map